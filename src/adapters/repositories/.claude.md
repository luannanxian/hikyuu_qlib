# Model Repository Adapter - Qlib 模型持久化集成方案

## 模块概述

**位置**: `src/adapters/repositories/`
**职责**: 实现 `IModelRepository` 接口,管理 Qlib 模型的序列化、持久化和加载
**优先级**: P1 - 中等复杂度
**状态**: ✅ 技术方案已完成

---

## 核心集成挑战

### 1. Qlib 模型序列化机制

**问题描述**:
- Qlib 使用 Recorder API 管理实验和模型持久化
- 需要将 Qlib 的 Recorder 机制适配到我们的 `IModelRepository` 接口
- 模型文件以 pickle 格式存储
- 需要同时管理模型元数据(超参数、指标等)

**Qlib 原生方式**:
```python
from qlib.workflow import R

# 保存模型
with R.start(experiment_name="train_model"):
    R.log_params(**flatten_dict(task))
    model.fit(dataset)
    R.save_objects(trained_model=model)
    rid = R.get_recorder().id

# 加载模型
recorder = R.get_recorder(recorder_id=rid, experiment_name="train_model")
model = recorder.load_object("trained_model")
```

### 2. 存储策略设计

**问题**: 如何组织模型文件和元数据的存储结构?

**解决方案**: 混合存储策略
- **模型文件**: pickle 格式存储到文件系统 (`data/models/{model_id}/model.pkl`)
- **元数据**: SQLite 数据库存储(模型ID、名称、超参数、评估指标、创建时间等)
- **实验追踪**: 可选集成 MLflow

**目录结构**:
```
data/
├── models/
│   ├── model_001/
│   │   ├── model.pkl         # Qlib 模型对象
│   │   ├── metadata.json     # 元数据快照
│   │   └── dataset.pkl       # 可选:训练数据集
│   └── model_002/
│       └── ...
└── models.db                 # SQLite 元数据库
```

### 3. 版本管理与实验追踪

**问题**: 如何管理模型版本和实验历史?

**解决方案**:
```python
class ModelMetadata:
    """模型元数据"""
    model_id: str
    experiment_name: str
    model_type: str  # "LGBM", "MLP", "LSTM"
    hyperparameters: Dict[str, Any]
    metrics: Dict[str, float]  # {"IC": 0.05, "ICIR": 1.2}
    created_at: datetime
    qlib_recorder_id: Optional[str]  # Qlib Recorder ID
    tags: Dict[str, str]
```

---

## 架构设计

### QlibModelRepository 类

```python
# src/adapters/repositories/qlib_model_repository.py

import pickle
import sqlite3
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any, List
from dataclasses import asdict

from domain.ports.model_repository import IModelRepository
from domain.entities.model_metadata import ModelMetadata


class QlibModelRepository(IModelRepository):
    """
    Qlib 模型仓库适配器

    核心功能:
    1. 保存 Qlib 模型为 pickle 文件
    2. 管理模型元数据到 SQLite
    3. 加载模型和元数据
    4. 可选集成 Qlib Recorder 和 MLflow
    """

    def __init__(
        self,
        models_dir: Path = Path("data/models"),
        db_path: Path = Path("data/models.db"),
        use_qlib_recorder: bool = False
    ):
        self.models_dir = models_dir
        self.db_path = db_path
        self.use_qlib_recorder = use_qlib_recorder

        # 确保目录存在
        self.models_dir.mkdir(parents=True, exist_ok=True)

        # 初始化数据库
        self._init_database()

    def _init_database(self):
        """初始化 SQLite 元数据库"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()

        cursor.execute("""
            CREATE TABLE IF NOT EXISTS models (
                model_id TEXT PRIMARY KEY,
                experiment_name TEXT NOT NULL,
                model_type TEXT NOT NULL,
                hyperparameters TEXT,  -- JSON
                metrics TEXT,           -- JSON
                created_at TEXT NOT NULL,
                qlib_recorder_id TEXT,
                tags TEXT              -- JSON
            )
        """)

        conn.commit()
        conn.close()

    async def save_model(
        self,
        model: Any,
        metadata: ModelMetadata
    ) -> str:
        """
        保存模型和元数据

        流程:
        1. 创建模型目录
        2. 序列化模型为 pickle
        3. 保存元数据到 SQLite
        4. 可选:使用 Qlib Recorder

        Returns:
            model_id: 模型唯一标识
        """
        model_id = metadata.model_id
        model_dir = self.models_dir / model_id
        model_dir.mkdir(parents=True, exist_ok=True)

        # 1. 保存模型文件 (pickle)
        model_path = model_dir / "model.pkl"
        with open(model_path, 'wb') as f:
            pickle.dump(model, f)

        # 2. 保存元数据快照 (JSON)
        import json
        metadata_path = model_dir / "metadata.json"
        with open(metadata_path, 'w') as f:
            json.dump(asdict(metadata), f, indent=2, default=str)

        # 3. 保存元数据到 SQLite
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()

        cursor.execute("""
            INSERT OR REPLACE INTO models (
                model_id, experiment_name, model_type,
                hyperparameters, metrics, created_at,
                qlib_recorder_id, tags
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            model_id,
            metadata.experiment_name,
            metadata.model_type,
            json.dumps(metadata.hyperparameters),
            json.dumps(metadata.metrics),
            metadata.created_at.isoformat(),
            metadata.qlib_recorder_id,
            json.dumps(metadata.tags) if metadata.tags else None
        ))

        conn.commit()
        conn.close()

        # 4. 可选:使用 Qlib Recorder
        if self.use_qlib_recorder:
            from qlib.workflow import R

            with R.start(experiment_name=metadata.experiment_name):
                R.log_params(**metadata.hyperparameters)
                R.log_metrics(**metadata.metrics)
                R.save_objects(**{"model.pkl": model})

                # 保存 Recorder ID
                recorder_id = R.get_recorder().id
                metadata.qlib_recorder_id = recorder_id

        return model_id

    async def load_model(self, model_id: str) -> tuple[Any, ModelMetadata]:
        """
        加载模型和元数据

        Returns:
            (model, metadata): 模型对象和元数据
        """
        model_dir = self.models_dir / model_id

        if not model_dir.exists():
            raise FileNotFoundError(f"模型不存在: {model_id}")

        # 1. 加载模型文件
        model_path = model_dir / "model.pkl"
        with open(model_path, 'rb') as f:
            model = pickle.load(f)

        # 2. 加载元数据
        metadata = await self.get_model_metadata(model_id)

        return model, metadata

    async def get_model_metadata(self, model_id: str) -> ModelMetadata:
        """从 SQLite 获取模型元数据"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()

        cursor.execute("""
            SELECT
                model_id, experiment_name, model_type,
                hyperparameters, metrics, created_at,
                qlib_recorder_id, tags
            FROM models
            WHERE model_id = ?
        """, (model_id,))

        row = cursor.fetchone()
        conn.close()

        if not row:
            raise ValueError(f"模型元数据不存在: {model_id}")

        import json

        return ModelMetadata(
            model_id=row[0],
            experiment_name=row[1],
            model_type=row[2],
            hyperparameters=json.loads(row[3]),
            metrics=json.loads(row[4]),
            created_at=datetime.fromisoformat(row[5]),
            qlib_recorder_id=row[6],
            tags=json.loads(row[7]) if row[7] else {}
        )

    async def list_models(
        self,
        experiment_name: Optional[str] = None,
        model_type: Optional[str] = None
    ) -> List[ModelMetadata]:
        """列出所有模型元数据"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()

        query = "SELECT * FROM models WHERE 1=1"
        params = []

        if experiment_name:
            query += " AND experiment_name = ?"
            params.append(experiment_name)

        if model_type:
            query += " AND model_type = ?"
            params.append(model_type)

        query += " ORDER BY created_at DESC"

        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()

        import json

        return [
            ModelMetadata(
                model_id=row[0],
                experiment_name=row[1],
                model_type=row[2],
                hyperparameters=json.loads(row[3]),
                metrics=json.loads(row[4]),
                created_at=datetime.fromisoformat(row[5]),
                qlib_recorder_id=row[6],
                tags=json.loads(row[7]) if row[7] else {}
            )
            for row in rows
        ]

    async def delete_model(self, model_id: str):
        """删除模型及其元数据"""
        import shutil

        # 1. 删除模型目录
        model_dir = self.models_dir / model_id
        if model_dir.exists():
            shutil.rmtree(model_dir)

        # 2. 删除元数据
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        cursor.execute("DELETE FROM models WHERE model_id = ?", (model_id,))
        conn.commit()
        conn.close()
```

---

## 集成 Qlib Recorder (可选)

### 双轨制存储

如果启用 Qlib Recorder,模型会被存储两次:
1. **我们的仓库**: `data/models/{model_id}/model.pkl`
2. **Qlib Recorder**: `~/.qlib/qlib_data/experiments/{experiment_name}/{recorder_id}/`

**优势**:
- 可以使用 Qlib 原生工具查看实验历史
- 集成 MLflow 进行可视化
- 保留我们的 Domain 层独立性

**实现**:
```python
async def save_model_with_recorder(
    self,
    model: Any,
    metadata: ModelMetadata,
    experiment_name: str
) -> str:
    """使用 Qlib Recorder 保存模型"""
    from qlib.workflow import R

    with R.start(experiment_name=experiment_name):
        # 记录超参数
        R.log_params(**metadata.hyperparameters)

        # 记录评估指标
        R.log_metrics(**metadata.metrics)

        # 保存模型对象
        R.save_objects(model=model)

        # 获取 Recorder ID
        recorder_id = R.get_recorder().id
        metadata.qlib_recorder_id = recorder_id

    # 同时保存到我们的仓库
    return await self.save_model(model, metadata)
```

---

## 使用示例

### 示例 1: 保存模型

```python
# examples/repositories/save_qlib_model.py

import asyncio
from pathlib import Path
from datetime import datetime
from qlib.contrib.model.gbdt import LGBModel

from adapters.repositories.qlib_model_repository import QlibModelRepository
from domain.entities.model_metadata import ModelMetadata


async def main():
    # 1. 创建仓库
    repo = QlibModelRepository(
        models_dir=Path("data/models"),
        use_qlib_recorder=True  # 启用 Qlib Recorder
    )

    # 2. 训练 Qlib 模型
    model = LGBModel()
    # ... 训练过程 ...

    # 3. 创建元数据
    metadata = ModelMetadata(
        model_id="lgbm_001",
        experiment_name="alpha158_lgbm",
        model_type="LGBM",
        hyperparameters={
            "learning_rate": 0.1,
            "num_leaves": 31,
            "n_estimators": 100
        },
        metrics={
            "IC": 0.05,
            "ICIR": 1.2,
            "Rank IC": 0.06
        },
        created_at=datetime.now(),
        tags={"dataset": "csi300", "features": "alpha158"}
    )

    # 4. 保存模型
    model_id = await repo.save_model(model, metadata)
    print(f"模型已保存: {model_id}")


if __name__ == "__main__":
    asyncio.run(main())
```

### 示例 2: 加载模型

```python
# examples/repositories/load_qlib_model.py

import asyncio
from pathlib import Path

from adapters.repositories.qlib_model_repository import QlibModelRepository


async def main():
    # 1. 创建仓库
    repo = QlibModelRepository(models_dir=Path("data/models"))

    # 2. 加载模型
    model, metadata = await repo.load_model("lgbm_001")

    print(f"模型类型: {metadata.model_type}")
    print(f"超参数: {metadata.hyperparameters}")
    print(f"评估指标: {metadata.metrics}")

    # 3. 使用模型预测
    # predictions = model.predict(dataset)


if __name__ == "__main__":
    asyncio.run(main())
```

### 示例 3: 列出所有模型

```python
import asyncio

async def list_all_models():
    repo = QlibModelRepository()

    # 列出所有 LGBM 模型
    models = await repo.list_models(model_type="LGBM")

    for metadata in models:
        print(f"模型ID: {metadata.model_id}")
        print(f"实验名称: {metadata.experiment_name}")
        print(f"IC: {metadata.metrics.get('IC', 'N/A')}")
        print(f"创建时间: {metadata.created_at}")
        print("---")


asyncio.run(list_all_models())
```

---

## Domain 层定义

### ModelMetadata 实体

```python
# src/domain/entities/model_metadata.py

from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any, Optional


@dataclass
class ModelMetadata:
    """模型元数据实体"""

    model_id: str
    experiment_name: str
    model_type: str  # "LGBM", "MLP", "LSTM"
    hyperparameters: Dict[str, Any]
    metrics: Dict[str, float]
    created_at: datetime
    qlib_recorder_id: Optional[str] = None
    tags: Dict[str, str] = None

    def __post_init__(self):
        if self.tags is None:
            self.tags = {}
```

### IModelRepository 端口

```python
# src/domain/ports/model_repository.py

from abc import ABC, abstractmethod
from typing import Any, Optional, List

from domain.entities.model_metadata import ModelMetadata


class IModelRepository(ABC):
    """模型仓库端口"""

    @abstractmethod
    async def save_model(
        self,
        model: Any,
        metadata: ModelMetadata
    ) -> str:
        """保存模型和元数据,返回 model_id"""
        pass

    @abstractmethod
    async def load_model(
        self,
        model_id: str
    ) -> tuple[Any, ModelMetadata]:
        """加载模型和元数据"""
        pass

    @abstractmethod
    async def get_model_metadata(
        self,
        model_id: str
    ) -> ModelMetadata:
        """获取模型元数据"""
        pass

    @abstractmethod
    async def list_models(
        self,
        experiment_name: Optional[str] = None,
        model_type: Optional[str] = None
    ) -> List[ModelMetadata]:
        """列出模型元数据"""
        pass

    @abstractmethod
    async def delete_model(self, model_id: str):
        """删除模型"""
        pass
```

---

## 测试策略

### 单元测试

```python
# tests/unit/adapters/repositories/test_qlib_model_repository.py

import pytest
import asyncio
from pathlib import Path
from datetime import datetime
from adapters.repositories.qlib_model_repository import QlibModelRepository
from domain.entities.model_metadata import ModelMetadata


@pytest.fixture
def temp_repo(tmp_path):
    """创建临时仓库"""
    return QlibModelRepository(
        models_dir=tmp_path / "models",
        db_path=tmp_path / "models.db"
    )


@pytest.mark.asyncio
async def test_save_and_load_model(temp_repo):
    """测试保存和加载模型"""
    # 创建模拟模型
    mock_model = {"type": "LGBM", "params": {"n_estimators": 100}}

    # 创建元数据
    metadata = ModelMetadata(
        model_id="test_001",
        experiment_name="test_exp",
        model_type="LGBM",
        hyperparameters={"n_estimators": 100},
        metrics={"IC": 0.05},
        created_at=datetime.now()
    )

    # 保存
    model_id = await temp_repo.save_model(mock_model, metadata)
    assert model_id == "test_001"

    # 加载
    loaded_model, loaded_metadata = await temp_repo.load_model(model_id)
    assert loaded_model == mock_model
    assert loaded_metadata.model_type == "LGBM"


@pytest.mark.asyncio
async def test_list_models(temp_repo):
    """测试列出模型"""
    # 保存多个模型
    for i in range(3):
        metadata = ModelMetadata(
            model_id=f"model_{i}",
            experiment_name="test_exp",
            model_type="LGBM",
            hyperparameters={},
            metrics={},
            created_at=datetime.now()
        )
        await temp_repo.save_model({}, metadata)

    # 列出所有模型
    models = await temp_repo.list_models()
    assert len(models) == 3


@pytest.mark.asyncio
async def test_delete_model(temp_repo):
    """测试删除模型"""
    metadata = ModelMetadata(
        model_id="to_delete",
        experiment_name="test_exp",
        model_type="LGBM",
        hyperparameters={},
        metrics={},
        created_at=datetime.now()
    )

    # 保存并删除
    await temp_repo.save_model({}, metadata)
    await temp_repo.delete_model("to_delete")

    # 验证已删除
    with pytest.raises(FileNotFoundError):
        await temp_repo.load_model("to_delete")
```

### 集成测试

```python
# tests/integration/test_qlib_model_persistence.py

import pytest
from qlib.contrib.model.gbdt import LGBModel
from adapters.repositories.qlib_model_repository import QlibModelRepository


@pytest.mark.asyncio
async def test_save_real_qlib_model(tmp_path):
    """测试保存真实 Qlib 模型"""
    # 创建真实 Qlib 模型
    model = LGBModel()

    # ... 训练模型 ...

    # 保存
    repo = QlibModelRepository(models_dir=tmp_path / "models")
    metadata = ModelMetadata(
        model_id="lgbm_real",
        experiment_name="real_test",
        model_type="LGBM",
        hyperparameters=model.get_params(),
        metrics={},
        created_at=datetime.now()
    )

    await repo.save_model(model, metadata)

    # 加载并验证
    loaded_model, _ = await repo.load_model("lgbm_real")
    assert isinstance(loaded_model, LGBModel)
```

---

## 性能优化

### 1. 批量加载

```python
async def load_models_batch(
    self,
    model_ids: List[str]
) -> List[tuple[Any, ModelMetadata]]:
    """批量加载模型"""
    import asyncio

    tasks = [self.load_model(model_id) for model_id in model_ids]
    return await asyncio.gather(*tasks)
```

### 2. 元数据缓存

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def _get_metadata_cached(self, model_id: str) -> ModelMetadata:
    """缓存元数据查询"""
    return asyncio.run(self.get_model_metadata(model_id))
```

### 3. 压缩存储

```python
import gzip

def _save_model_compressed(self, model_path: Path, model: Any):
    """压缩保存模型"""
    with gzip.open(f"{model_path}.gz", 'wb') as f:
        pickle.dump(model, f)
```

---

## 后续优化方向

1. **模型版本管理**: 支持同一模型的多个版本
2. **自动清理策略**: 定期清理过期或低性能模型
3. **分布式存储**: 支持 S3/MinIO 等对象存储
4. **模型比较工具**: 对比不同模型的性能指标
5. **数据集关联**: 记录训练数据集的元信息

---

## 参考文档

- Qlib Recorder API: https://qlib.readthedocs.io/en/latest/component/recorder.html
- MLflow Integration: https://mlflow.org/docs/latest/python_api/mlflow.html
- Domain 端口定义: [`src/domain/ports/model_repository.py`](../../domain/ports/model_repository.py)
- 实体定义: [`src/domain/entities/model_metadata.py`](../../domain/entities/model_metadata.py)

---

**最后更新**: 2025-11-11
**状态**: ✅ 技术方案已完成,待实现
