# Domain å±‚ - Claude AI å¼€å‘æŒ‡å—

## æ¨¡å—æ¦‚è¿°

Domain å±‚æ˜¯ç³»ç»Ÿçš„**æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å±‚**,åŒ…å«æ‰€æœ‰ä¸šåŠ¡è§„åˆ™å’Œé¢†åŸŸçŸ¥è¯†,**å®Œå…¨ç‹¬ç«‹äºå¤–éƒ¨æ¡†æ¶å’ŒæŠ€æœ¯å®ç°**ã€‚

**æ¶æ„åŸåˆ™**:
- âœ… **é›¶å¤–éƒ¨ä¾èµ–** - ä¸ä¾èµ– Hikyuuã€Qlib æˆ–ä»»ä½•æ¡†æ¶
- âœ… **çº¯ä¸šåŠ¡é€»è¾‘** - åªåŒ…å«é¢†åŸŸæ¦‚å¿µå’Œè§„åˆ™
- âœ… **é«˜åº¦å¯æµ‹è¯•** - æ— éœ€æ•°æ®åº“ã€API å³å¯æµ‹è¯•
- âœ… **æŠ€æœ¯æ— å…³** - å¯ä»¥åœ¨ä»»ä½•æŠ€æœ¯æ ˆä¸­å¤ç”¨

**æ ¸å¿ƒèŒè´£**:
1. å®šä¹‰é¢†åŸŸå®ä½“ (Entities)
2. å®šä¹‰å€¼å¯¹è±¡ (Value Objects)
3. å®šä¹‰èšåˆæ ¹ (Aggregates)
4. å®šä¹‰é¢†åŸŸäº‹ä»¶ (Domain Events)
5. å®šä¹‰ç«¯å£æ¥å£ (Ports)
6. å®ç°é¢†åŸŸæœåŠ¡ (Domain Services)

## TDD å¼€å‘è¦æ±‚ ğŸ§ª

### å¿…é¡»éµå¾ªçš„ TDD æµç¨‹

**å¯¹äº Domain å±‚çš„æ¯ä¸ªç±»/æ–¹æ³•**:

1. **å…ˆç¼–å†™æµ‹è¯•** (tests/unit/domain/)
2. **è¿è¡Œæµ‹è¯•ç¡®è®¤å¤±è´¥** (ğŸ”´ RED)
3. **ç¼–å†™æœ€å°å®ç°**
4. **è¿è¡Œæµ‹è¯•ç¡®è®¤é€šè¿‡** (ğŸŸ¢ GREEN)
5. **é‡æ„ä¼˜åŒ–** (ğŸ”µ REFACTOR)

### æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

- **Entities**: >= 95% (æ ¸å¿ƒä¸šåŠ¡é€»è¾‘)
- **Value Objects**: >= 100% (ä¸å¯å˜å¯¹è±¡,å¿…é¡»å®Œå…¨è¦†ç›–)
- **Aggregates**: >= 95%
- **Domain Services**: >= 90%
- **Ports (æ¥å£)**: 100% (æ¥å£å®šä¹‰)
- **æ•´ä½“ Domain å±‚**: >= 95%

## å­æ¨¡å—è¯´æ˜

### 1. entities/ - å®ä½“

**å®šä¹‰**: å…·æœ‰**å”¯ä¸€æ ‡è¯†**çš„é¢†åŸŸå¯¹è±¡,å¯å˜,æœ‰ç”Ÿå‘½å‘¨æœŸã€‚

**ç¤ºä¾‹**:

```python
# domain/entities/stock.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from ..value_objects.market import Market
from ..value_objects.stock_code import StockCode

@dataclass
class Stock:
    """å®ä½“: è‚¡ç¥¨

    ç‰¹ç‚¹:
    - æœ‰å”¯ä¸€æ ‡è¯† (code)
    - å¯å˜çŠ¶æ€ (is_active)
    - åŒ…å«ä¸šåŠ¡è§„åˆ™
    """
    code: StockCode  # å€¼å¯¹è±¡
    name: str
    market: Market  # å€¼å¯¹è±¡
    listed_date: datetime
    is_active: bool = True

    def deactivate(self):
        """ä¸šåŠ¡è§„åˆ™: åœç‰Œè‚¡ç¥¨"""
        if not self.is_active:
            raise ValueError(f"Stock {self.code} is already inactive")
        self.is_active = False

    def is_tradable(self) -> bool:
        """ä¸šåŠ¡è§„åˆ™: æ˜¯å¦å¯äº¤æ˜“"""
        return self.is_active and self.market.is_open()

    def __eq__(self, other):
        """å®ä½“ç›¸ç­‰æ€§: åªæ¯”è¾ƒ ID"""
        if not isinstance(other, Stock):
            return False
        return self.code == other.code

# domain/entities/model.py
from dataclasses import dataclass, field
from typing import Dict, List
from ..events.model_trained_event import ModelTrainedEvent

@dataclass
class Model:
    """å®ä½“: è®­ç»ƒæ¨¡å‹"""
    id: str
    name: str
    model_type: str  # 'LGBModel', 'XGBModel'
    version: str
    metrics: Dict[str, float] = field(default_factory=dict)
    _events: List = field(default_factory=list, repr=False)

    def record_metric(self, name: str, value: float):
        """ä¸šåŠ¡è§„åˆ™: è®°å½•æŒ‡æ ‡"""
        if value < -1 or value > 1:
            raise ValueError(f"Metric {name} out of range: {value}")
        self.metrics[name] = value

    def mark_as_trained(self):
        """ä¸šåŠ¡è§„åˆ™: æ ‡è®°ä¸ºå·²è®­ç»ƒ"""
        if not self.metrics:
            raise ValueError("Cannot mark as trained without metrics")
        self._events.append(ModelTrainedEvent(self.id, self.metrics))
```

### 2. value_objects/ - å€¼å¯¹è±¡

**å®šä¹‰**: **ä¸å¯å˜å¯¹è±¡**,é€šè¿‡å±æ€§å®šä¹‰,æ— å”¯ä¸€æ ‡è¯†ã€‚

**ç¤ºä¾‹**:

```python
# domain/value_objects/stock_code.py
from dataclasses import dataclass

@dataclass(frozen=True)
class StockCode:
    """å€¼å¯¹è±¡: è‚¡ç¥¨ä»£ç 

    ç‰¹ç‚¹:
    - ä¸å¯å˜ (frozen=True)
    - è‡ªåŒ…å«éªŒè¯
    - å€¼ç›¸ç­‰æ€§
    """
    value: str

    def __post_init__(self):
        """éªŒè¯è§„åˆ™"""
        if not self.value:
            raise ValueError("Stock code cannot be empty")

        # éªŒè¯æ ¼å¼: sh000001 æˆ– sz000001
        if len(self.value) != 8:
            raise ValueError(f"Invalid stock code format: {self.value}")

        market = self.value[:2].lower()
        if market not in ['sh', 'sz']:
            raise ValueError(f"Unknown market: {market}")

        code_num = self.value[2:]
        if not code_num.isdigit():
            raise ValueError(f"Invalid code number: {code_num}")

    @property
    def market_code(self) -> str:
        """æå–å¸‚åœºä»£ç """
        return self.value[:2].upper()

    @property
    def code_number(self) -> str:
        """æå–ä»£ç æ•°å­—"""
        return self.value[2:]

# domain/value_objects/price.py
from dataclasses import dataclass
from decimal import Decimal

@dataclass(frozen=True)
class Price:
    """å€¼å¯¹è±¡: ä»·æ ¼"""
    value: Decimal
    currency: str = "CNY"

    def __post_init__(self):
        if self.value < 0:
            raise ValueError("Price cannot be negative")

        # ç¡®ä¿ç²¾åº¦
        object.__setattr__(self, 'value',
                          self.value.quantize(Decimal('0.01')))

    def add(self, other: "Price") -> "Price":
        """ä¸å¯å˜æ“ä½œ: è¿”å›æ–°å¯¹è±¡"""
        if self.currency != other.currency:
            raise ValueError("Currency mismatch")
        return Price(self.value + other.value, self.currency)

    def multiply(self, factor: Decimal) -> "Price":
        """è®¡ç®—ä»·æ ¼"""
        return Price(self.value * factor, self.currency)

# domain/value_objects/date_range.py
from dataclasses import dataclass
from datetime import datetime

@dataclass(frozen=True)
class DateRange:
    """å€¼å¯¹è±¡: æ—¥æœŸèŒƒå›´"""
    start: datetime
    end: datetime

    def __post_init__(self):
        if self.start > self.end:
            raise ValueError("Start date must be before end date")

    def contains(self, date: datetime) -> bool:
        """æ£€æŸ¥æ—¥æœŸæ˜¯å¦åœ¨èŒƒå›´å†…"""
        return self.start <= date <= self.end

    def overlaps(self, other: "DateRange") -> bool:
        """æ£€æŸ¥æ˜¯å¦é‡å """
        return self.start <= other.end and other.start <= self.end
```

### 3. aggregates/ - èšåˆæ ¹

**å®šä¹‰**: **ä¸€è‡´æ€§è¾¹ç•Œ**,æ§åˆ¶å¯¹å®ä½“å’Œå€¼å¯¹è±¡çš„è®¿é—®ã€‚

**ç¤ºä¾‹**:

```python
# domain/aggregates/trading_day.py
from dataclasses import dataclass, field
from datetime import datetime
from typing import List
from ..entities.stock import Stock
from ..value_objects.price import Price
from ..events.bar_added_event import BarAddedEvent

@dataclass
class PriceBar:
    """ä»·æ ¼æŸ±"""
    datetime: datetime
    open: Price
    high: Price
    low: Price
    close: Price
    volume: int

class TradingDay:
    """èšåˆæ ¹: äº¤æ˜“æ—¥æ•°æ®

    èŒè´£:
    - ç®¡ç†ä¸€å¤©çš„æ‰€æœ‰ä»·æ ¼æ•°æ®
    - ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
    - å‘å¸ƒé¢†åŸŸäº‹ä»¶
    """

    def __init__(self, stock: Stock, date: datetime):
        self.stock = stock
        self.date = date
        self._bars: List[PriceBar] = []
        self._events: List = []

    def add_bar(self, bar: PriceBar):
        """ä¸šåŠ¡è§„åˆ™: æ·»åŠ ä»·æ ¼æŸ±"""
        # éªŒè¯è§„åˆ™
        if not self.stock.is_tradable():
            raise ValueError(
                f"Cannot add bar for non-tradable stock {self.stock.code}"
            )

        if bar.datetime.date() != self.date.date():
            raise ValueError("Bar date must match trading day")

        # éªŒè¯ä»·æ ¼æœ‰æ•ˆæ€§
        if bar.high < bar.low:
            raise ValueError("High must be >= Low")

        if bar.open > bar.high or bar.open < bar.low:
            raise ValueError("Open must be between High and Low")

        if bar.close > bar.high or bar.close < bar.low:
            raise ValueError("Close must be between High and Low")

        self._bars.append(bar)
        self._events.append(BarAddedEvent(self.stock.code, bar))

    @property
    def bars(self) -> List[PriceBar]:
        """åªè¯»è®¿é—®"""
        return self._bars.copy()

    def get_close_price(self) -> Price:
        """è·å–æ”¶ç›˜ä»·"""
        if not self._bars:
            raise ValueError("No bars available")
        return self._bars[-1].close

# domain/aggregates/portfolio.py
from typing import Dict
from ..entities.stock import Stock
from ..value_objects.price import Price
from decimal import Decimal

class Portfolio:
    """èšåˆæ ¹: æŠ•èµ„ç»„åˆ"""

    def __init__(self, id: str, name: str, initial_cash: Price):
        self.id = id
        self.name = name
        self._cash = initial_cash
        self._positions: Dict[str, int] = {}  # stock_code -> shares
        self._events = []

    def buy(self, stock: Stock, shares: int, price: Price):
        """ä¸šåŠ¡è§„åˆ™: ä¹°å…¥è‚¡ç¥¨"""
        if shares <= 0:
            raise ValueError("Shares must be positive")

        cost = price.multiply(Decimal(shares))

        if cost.value > self._cash.value:
            raise ValueError("Insufficient cash")

        self._cash = Price(self._cash.value - cost.value)

        current_shares = self._positions.get(stock.code.value, 0)
        self._positions[stock.code.value] = current_shares + shares

    def sell(self, stock: Stock, shares: int, price: Price):
        """ä¸šåŠ¡è§„åˆ™: å–å‡ºè‚¡ç¥¨"""
        if shares <= 0:
            raise ValueError("Shares must be positive")

        current_shares = self._positions.get(stock.code.value, 0)
        if shares > current_shares:
            raise ValueError("Insufficient shares")

        proceeds = price.multiply(Decimal(shares))
        self._cash = Price(self._cash.value + proceeds.value)

        self._positions[stock.code.value] = current_shares - shares

    @property
    def cash(self) -> Price:
        """åªè¯»è®¿é—®ç°é‡‘"""
        return self._cash
```

### 4. events/ - é¢†åŸŸäº‹ä»¶

**å®šä¹‰**: é¢†åŸŸä¸­**å·²å‘ç”Ÿçš„äº‹æƒ…**ã€‚

**ç¤ºä¾‹**:

```python
# domain/events/domain_event.py
from dataclasses import dataclass
from datetime import datetime
from abc import ABC

@dataclass
class DomainEvent(ABC):
    """åŸºç¡€é¢†åŸŸäº‹ä»¶"""
    occurred_at: datetime = field(default_factory=datetime.now)

# domain/events/model_trained_event.py
from dataclasses import dataclass
from typing import Dict
from .domain_event import DomainEvent

@dataclass
class ModelTrainedEvent(DomainEvent):
    """äº‹ä»¶: æ¨¡å‹è®­ç»ƒå®Œæˆ"""
    model_id: str
    metrics: Dict[str, float]

# domain/events/bar_added_event.py
from dataclasses import dataclass
from .domain_event import DomainEvent
from ..value_objects.stock_code import StockCode

@dataclass
class BarAddedEvent(DomainEvent):
    """äº‹ä»¶: ä»·æ ¼æŸ±æ·»åŠ """
    stock_code: StockCode
    bar: object  # PriceBar
```

### 5. ports/ - ç«¯å£æ¥å£

**å®šä¹‰**: Domain å±‚å®šä¹‰çš„**æŠ½è±¡æ¥å£**,ç”± Adapters å±‚å®ç°ã€‚

**ç¤ºä¾‹**:

```python
# domain/ports/stock_data_provider.py
from abc import ABC, abstractmethod
from typing import List, Optional
import pandas as pd
from ..entities.stock import Stock
from ..value_objects.date_range import DateRange
from ..value_objects.stock_code import StockCode

class IStockDataProvider(ABC):
    """Port: è‚¡ç¥¨æ•°æ®æä¾›è€…

    ç”± Adapters å±‚å®ç°:
    - HikyuuDataAdapter
    - MockDataAdapter (æµ‹è¯•)
    """

    @abstractmethod
    async def load_stock_data(
        self,
        code: StockCode,
        date_range: DateRange
    ) -> pd.DataFrame:
        """åŠ è½½è‚¡ç¥¨æ•°æ®

        Args:
            code: è‚¡ç¥¨ä»£ç 
            date_range: æ—¥æœŸèŒƒå›´

        Returns:
            DataFrame with columns: datetime, open, high, low, close, volume
        """
        pass

    @abstractmethod
    async def get_stock_info(self, code: StockCode) -> Optional[Stock]:
        """è·å–è‚¡ç¥¨ä¿¡æ¯"""
        pass

    @abstractmethod
    async def get_all_stocks(self) -> List[Stock]:
        """è·å–æ‰€æœ‰è‚¡ç¥¨"""
        pass

# domain/ports/model_trainer.py
from abc import ABC, abstractmethod
from typing import Dict, Any
from ..entities.model import Model

class IModelTrainer(ABC):
    """Port: æ¨¡å‹è®­ç»ƒå™¨"""

    @abstractmethod
    async def train(
        self,
        model_type: str,
        dataset: Any,  # Domain ä¸å…³å¿ƒå…·ä½“ç±»å‹
        parameters: Dict[str, Any]
    ) -> Model:
        """è®­ç»ƒæ¨¡å‹"""
        pass

    @abstractmethod
    async def predict(
        self,
        model: Model,
        data: Any
    ) -> Any:
        """ç”Ÿæˆé¢„æµ‹"""
        pass

# domain/ports/backtest_engine.py
from abc import ABC, abstractmethod
from typing import Dict, Any
from ..aggregates.portfolio import Portfolio

class IBacktestEngine(ABC):
    """Port: å›æµ‹å¼•æ“"""

    @abstractmethod
    async def run_backtest(
        self,
        portfolio: Portfolio,
        signals: Any,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """æ‰§è¡Œå›æµ‹"""
        pass
```

### 6. services/ - é¢†åŸŸæœåŠ¡

**å®šä¹‰**: æ— çŠ¶æ€çš„é¢†åŸŸé€»è¾‘,ä¸å±äºä»»ä½•å®ä½“æˆ–å€¼å¯¹è±¡ã€‚

**ç¤ºä¾‹**:

```python
# domain/services/price_adjustment_service.py
from typing import List
from decimal import Decimal
from ..value_objects.price import Price

class PriceAdjustmentService:
    """é¢†åŸŸæœåŠ¡: ä»·æ ¼å¤æƒ

    ä¸šåŠ¡è§„åˆ™:
    - å‰å¤æƒ: è°ƒæ•´å†å²ä»·æ ¼
    - åå¤æƒ: è°ƒæ•´æœ€æ–°ä»·æ ¼
    """

    @staticmethod
    def forward_adjust(
        prices: List[Price],
        factors: List[Decimal]
    ) -> List[Price]:
        """å‰å¤æƒ"""
        if len(prices) != len(factors):
            raise ValueError("Prices and factors must have same length")

        adjusted = []
        for price, factor in zip(prices, factors):
            adjusted_value = price.value * factor
            adjusted.append(Price(adjusted_value, price.currency))

        return adjusted

    @staticmethod
    def backward_adjust(
        prices: List[Price],
        factors: List[Decimal]
    ) -> List[Price]:
        """åå¤æƒ"""
        if len(prices) != len(factors):
            raise ValueError("Prices and factors must have same length")

        if not factors:
            return prices

        # ä½¿ç”¨æœ€åä¸€ä¸ªå› å­ä½œä¸ºåŸºå‡†
        base_factor = factors[-1]

        adjusted = []
        for price, factor in zip(prices, factors):
            ratio = base_factor / factor
            adjusted_value = price.value * ratio
            adjusted.append(Price(adjusted_value, price.currency))

        return adjusted

# domain/services/indicator_service.py
from abc import ABC, abstractmethod
from typing import List
from ..value_objects.price import Price

class IIndicatorCalculator(ABC):
    """Port: æŒ‡æ ‡è®¡ç®—å™¨ (å®šä¹‰åœ¨ Domain,å®ç°åœ¨ Adapter)"""

    @abstractmethod
    def calculate_macd(
        self,
        prices: List[Price],
        fast: int = 12,
        slow: int = 26,
        signal: int = 9
    ) -> List[tuple]:
        """è®¡ç®— MACD"""
        pass
```

## TDD ç¤ºä¾‹

### ç¤ºä¾‹ 1: StockCode å€¼å¯¹è±¡ TDD

```python
# tests/unit/domain/value_objects/test_stock_code.py
import pytest
from src.domain.value_objects.stock_code import StockCode

class TestStockCode:
    """StockCode TDD æµ‹è¯•å¥—ä»¶"""

    def test_create_valid_sh_stock_code(self):
        """ğŸ”´ æµ‹è¯•: åˆ›å»ºæœ‰æ•ˆçš„ä¸Šæµ·è‚¡ç¥¨ä»£ç """
        code = StockCode("sh000001")

        assert code.value == "sh000001"
        assert code.market_code == "SH"
        assert code.code_number == "000001"

    def test_create_valid_sz_stock_code(self):
        """ğŸ”´ æµ‹è¯•: åˆ›å»ºæœ‰æ•ˆçš„æ·±åœ³è‚¡ç¥¨ä»£ç """
        code = StockCode("sz000001")

        assert code.market_code == "SZ"

    def test_reject_empty_code(self):
        """ğŸ”´ æµ‹è¯•: æ‹’ç»ç©ºä»£ç """
        with pytest.raises(ValueError, match="cannot be empty"):
            StockCode("")

    def test_reject_invalid_format(self):
        """ğŸ”´ æµ‹è¯•: æ‹’ç»æ— æ•ˆæ ¼å¼"""
        with pytest.raises(ValueError, match="Invalid stock code format"):
            StockCode("sh001")  # å¤ªçŸ­

    def test_reject_unknown_market(self):
        """ğŸ”´ æµ‹è¯•: æ‹’ç»æœªçŸ¥å¸‚åœº"""
        with pytest.raises(ValueError, match="Unknown market"):
            StockCode("bj000001")

    def test_value_equality(self):
        """ğŸ”´ æµ‹è¯•: å€¼å¯¹è±¡ç›¸ç­‰æ€§"""
        code1 = StockCode("sh000001")
        code2 = StockCode("sh000001")
        code3 = StockCode("sz000001")

        assert code1 == code2
        assert code1 != code3

    def test_immutability(self):
        """ğŸ”´ æµ‹è¯•: ä¸å¯å˜æ€§"""
        code = StockCode("sh000001")

        with pytest.raises(AttributeError):
            code.value = "sh000002"  # åº”è¯¥å¤±è´¥
```

### ç¤ºä¾‹ 2: Stock å®ä½“ TDD

```python
# tests/unit/domain/entities/test_stock.py
import pytest
from datetime import datetime
from src.domain.entities.stock import Stock
from src.domain.value_objects.stock_code import StockCode
from src.domain.value_objects.market import Market

class TestStock:
    """Stock TDD æµ‹è¯•å¥—ä»¶"""

    @pytest.fixture
    def sample_stock(self):
        """æµ‹è¯• fixture"""
        return Stock(
            code=StockCode("sh000001"),
            name="å¹³å®‰é“¶è¡Œ",
            market=Market("SH", "ä¸Šæµ·è¯åˆ¸äº¤æ˜“æ‰€"),
            listed_date=datetime(2010, 1, 1),
            is_active=True
        )

    def test_create_stock(self, sample_stock):
        """ğŸ”´ æµ‹è¯•: åˆ›å»ºè‚¡ç¥¨"""
        assert sample_stock.code.value == "sh000001"
        assert sample_stock.is_active is True

    def test_deactivate_stock(self, sample_stock):
        """ğŸ”´ æµ‹è¯•: åœç‰Œè‚¡ç¥¨"""
        sample_stock.deactivate()

        assert sample_stock.is_active is False

    def test_cannot_deactivate_twice(self, sample_stock):
        """ğŸ”´ æµ‹è¯•: ä¸èƒ½é‡å¤åœç‰Œ"""
        sample_stock.deactivate()

        with pytest.raises(ValueError, match="already inactive"):
            sample_stock.deactivate()

    def test_entity_equality_by_id(self):
        """ğŸ”´ æµ‹è¯•: å®ä½“ç›¸ç­‰æ€§ (åªæ¯”è¾ƒ ID)"""
        stock1 = Stock(
            code=StockCode("sh000001"),
            name="Name1",
            market=Market("SH", ""),
            listed_date=datetime(2010, 1, 1)
        )

        stock2 = Stock(
            code=StockCode("sh000001"),
            name="Name2",  # åå­—ä¸åŒ
            market=Market("SH", ""),
            listed_date=datetime(2010, 1, 1)
        )

        # å®ä½“ç›¸ç­‰æ€§åªçœ‹ ID
        assert stock1 == stock2
```

## æ¶æ„æµ‹è¯•

```python
# tests/architecture/test_domain_dependencies.py
import pytest
from pathlib import Path

class TestDomainArchitecture:
    """Domain å±‚æ¶æ„è§„åˆ™æµ‹è¯•"""

    def test_domain_has_no_framework_dependencies(self):
        """Domain å±‚ä¸èƒ½ä¾èµ–ä»»ä½•æ¡†æ¶"""
        domain_files = Path("src/domain").rglob("*.py")

        forbidden_imports = [
            "hikyuu", "qlib", "fastapi", "django",
            "sqlalchemy", "asyncpg", "redis"
        ]

        violations = []
        for file in domain_files:
            content = file.read_text()
            for forbidden in forbidden_imports:
                if f"import {forbidden}" in content:
                    violations.append(f"{file}: imports {forbidden}")

        assert not violations, "\n".join(violations)

    def test_domain_can_import_standard_library(self):
        """Domain å±‚å¯ä»¥å¯¼å…¥æ ‡å‡†åº“"""
        # å…è®¸çš„å¯¼å…¥
        allowed = [
            "from abc import",
            "from dataclasses import",
            "from datetime import",
            "from typing import",
            "from decimal import"
        ]
        # è¿™ä¸ªæµ‹è¯•ç¡®ä¿æˆ‘ä»¬çŸ¥é“å“ªäº›æ˜¯å…è®¸çš„
```

## å¼€å‘æ—¶é—´è¡¨

| å­æ¨¡å— | é¢„ä¼° | TDD æµç¨‹ |
|--------|------|----------|
| Value Objects | 3å¤© | æµ‹è¯•(1å¤©) + å®ç°(1.5å¤©) + é‡æ„(0.5å¤©) |
| Entities | 3å¤© | æµ‹è¯•(1å¤©) + å®ç°(1.5å¤©) + é‡æ„(0.5å¤©) |
| Aggregates | 4å¤© | æµ‹è¯•(1.5å¤©) + å®ç°(2å¤©) + é‡æ„(0.5å¤©) |
| Events | 1å¤© | æµ‹è¯•(0.5å¤©) + å®ç°(0.5å¤©) |
| Ports | 2å¤© | å®šä¹‰æ¥å£(1å¤©) + æ–‡æ¡£(1å¤©) |
| Services | 2å¤© | æµ‹è¯•(0.5å¤©) + å®ç°(1å¤©) + é‡æ„(0.5å¤©) |
| æ¶æ„æµ‹è¯• | 1å¤© | - |
| **æ€»è®¡** | **16å¤©** | **çº¦ 3 å‘¨** |

---

**æ¨¡å—è´Ÿè´£äºº**: Domain Team
**ä¼˜å…ˆçº§**: P0 (æœ€é«˜ - æ ¸å¿ƒåŸºç¡€)
**é¢„ä¼°å·¥æœŸ**: 3 å‘¨
**ä¾èµ–**: æ—  (æœ€åº•å±‚)
**å½“å‰çŠ¶æ€**: å¾…å¼€å§‹

**é‡è¦æç¤º**:
- âš ï¸ Domain å±‚ç»å¯¹ä¸èƒ½ä¾èµ–å¤–éƒ¨æ¡†æ¶
- âš ï¸ æ‰€æœ‰ä¸šåŠ¡è§„åˆ™å¿…é¡»åœ¨ Domain å±‚å®ç°
- âš ï¸ æµ‹è¯•è¦†ç›–ç‡å¿…é¡» >= 95%
- âš ï¸ å€¼å¯¹è±¡å¿…é¡»ä¸å¯å˜
- âš ï¸ å®ä½“ç›¸ç­‰æ€§åªæ¯”è¾ƒ ID
