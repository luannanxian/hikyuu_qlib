{"design":{"lastTaskId":"b84c1b33-be81-45e8-98bf-2c845e9cbc2d","lastCheckpointId":"5e0155ed7e3e05c68e1667f9cbd28556cecff57e","content":"# 架构设计文档 - Hikyuu × Qlib 个人量化工作站\n\n## 1. 架构概述\n\n### 1.1 架构目标\n\n**可扩展性:**\n\n- 支持模块化组件设计，便于未来功能扩展\n- 允许用户自定义策略组件和数据处理流程\n- 支持多种数据源和模型类型的插件式接入\n\n### 1.2 架构原则\n\n- **单一职责原则**: 每个模块专注于特定功能领域\n- **开闭原则**: 对扩展开放，对修改关闭\n- **里氏替换原则**: 组件接口支持互相替换\n- **接口隔离原则**: 最小化接口依赖关系\n- **依赖倒置原则**: 高层模块不依赖低层模块实现\n\n## 2. 系统架构\n\n### 2.1 整体架构图\n\n```mermaid\ngraph TB\n    subgraph 命令行交互层\n        A[配置管理工具 hikyuu-qlib-config]\n        B[数据处理工具 hikyuu-qlib-data]\n        C[模型训练工具 hikyuu-qlib-train]\n        D[回测执行工具 hikyuu-qlib-backtest]\n        E[复盘分析工具 hikyuu-qlib-analyze]\n    end\n    \n    subgraph 业务逻辑层\n        F[数据流通模块]\n        G[机器学习建模模块]\n        H[策略执行模块]\n        I[配置管理模块]\n        J[复盘分析模块]\n    end\n    \n    subgraph 框架集成层\n        K[Hikyuu Python API集成]\n        L[Qlib API集成]\n        M[信号转换处理]\n    end\n    \n    subgraph 数据存储层\n        N[Hikyuu HDF5数据]\n        O[Qlib .bin数据]\n        P[配置文件]\n        Q[预测结果文件]\n        R[信号文件]\n    end\n    \n    A --> I\n    B --> F\n    C --> G\n    D --> H\n    E --> J\n    \n    F --> K\n    F --> L\n    G --> L\n    H --> K\n    H --> M\n    I --> P\n    \n    K --> N\n    L --> O\n    M --> R\n    G --> Q\n```\n\n### 2.2 架构分层\n\n#### 2.2.1 用户界面层\n\n- **命令行配置管理工具**: 提供命令行接口编辑和管理配置文件\n- **数据配置命令行向导**: 通过命令行引导用户完成Hikyuu数据源配置\n- **策略执行命令行工具**: 展示模型训练、信号生成、回测执行进度\n- **复盘分析命令行工具**: 提供回测结果可视化和多策略对比功能\n\n#### 2.2.2 业务逻辑层\n\n- **数据流通模块**: 负责Hikyuu数据到Qlib的数据加载和转换\n- **机器学习建模模块**: 提供Qlib模型训练、预测和实验管理功能\n- **策略执行模块**: 处理信号转换和Hikyuu回测执行\n- **配置管理模块**: 统一管理系统配置和参数\n- **复盘分析模块**: 生成回测报告和策略对比分析\n\n#### 2.2.3 框架集成层\n\n- **Hikyuu Python API集成**: 封装Hikyuu Python API核心功能接口\n- **Qlib API集成**: 封装Qlib API核心功能接口\n- **信号转换处理**: 实现Qlib预测结果到Hikyuu信号的格式转换\n\n#### 2.2.4 数据存储层\n\n- **Hikyuu HDF5数据**: 存储原始行情数据和复权因子\n- **Qlib .bin数据**: 存储Qlib格式的特征数据\n- **配置文件**: Hikyuu INI格式和Qlib YAML格式的系统配置\n- **预测结果文件**: Qlib模型输出的pred.pkl文件\n- **信号文件**: 转换后的Hikyuu信号文件（CSV/JSON）\n\n## 3. 服务设计\n\n### 3.1 模块拆分\n\n| 模块名称 | 职责 | 技术栈 | 数据存储 | 命令行工具 |\n|----------|------|--------|--------|------------|\n| 数据流通模块 | Hikyuu数据加载、格式转换、特征计算 | Python + Pandas + HDF5 | HDF5 + .bin文件 | hikyuu-qlib-data |\n| 机器学习建模模块 | 模型训练、预测、实验管理 | Python + Qlib + LightGBM | pred.pkl + 实验记录 | hikyuu-qlib-train |\n| 策略执行模块 | 信号转换、回测执行、调仓建议 | Python + Hikyuu | CSV/JSON信号文件 | hikyuu-qlib-backtest |\n| 配置管理模块 | 统一配置管理、参数验证 | Python + PyYAML | YAML/INI配置文件 | hikyuu-qlib-config |\n| 复盘分析模块 | 回测报告生成、策略对比 | Python + Matplotlib | 报告文件 + 图表 | hikyuu-qlib-analyze |\n\n### 3.2 模块间通信\n\n#### 3.2.1 同步通信\n\n- **协议**: 函数调用 + 文件传递\n- **数据格式**: HDF5、.bin、CSV、JSON、YAML/INI\n\n#### 3.2.2 异步通信\n\n- **消息队列**: 不涉及（个人量化工作站无需复杂消息队列）\n- **事件驱动**: 基于文件系统事件和配置变更事件\n\n### 3.3 命令行工具设计\n\n#### 3.3.1 数据处理命令行工具 (hikyuu-qlib-data)\n\n```bash\n# 初始化Hikyuu数据\nhikyuu-qlib-data init --config hikyuu.ini --data-dir ./data/hikyuu\n\n# 转换Hikyuu数据到Qlib格式\nhikyuu-qlib-data convert --source ./data/hikyuu --target ./data/qlib --instruments sh000001,sz000001\n\n# 验证数据完整性\nhikyuu-qlib-data validate --source ./data/hikyuu --target ./data/qlib\n```\n\n#### 3.3.2 模型训练命令行工具 (hikyuu-qlib-train)\n\n```bash\n# 训练模型\nhikyuu-qlib-train train --config config.yaml --model LGBModel --experiment exp_001\n\n# 预测\nhikyuu-qlib-train predict --model-path ./models/exp_001 --data-config data_config.yaml\n\n# 查看实验记录\nhikyuu-qlib-train list --experiments\n```\n\n#### 3.3.3 回测执行命令行工具 (hikyuu-qlib-backtest)\n\n```bash\n# 执行回测\nhikyuu-qlib-backtest run --prediction ./results/pred.pkl --signal-format CSV --start-date 2021-01-01 --end-date 2023-12-31\n\n# 生成回测报告\nhikyuu-qlib-backtest report --results-path ./results --output-format html\n\n# 查看回测结果\nhikyuu-qlib-backtest summary --results-path ./results\n```\n\n#### 3.3.4 配置管理命令行工具 (hikyuu-qlib-config)\n\n```bash\n# 生成默认配置\nhikyuu-qlib-config generate --type hikyuu --output hikyuu.ini\nhikyuu-qlib-config generate --type qlib --output config.yaml\n\n# 验证配置\nhikyuu-qlib-config validate --config config.yaml\n\n# 更新配置\nhikyuu-qlib-config update --config config.yaml --key model.type --value LGBModel\n```\n\n#### 3.3.5 复盘分析命令行工具 (hikyuu-qlib-analyze)\n\n```bash\n# 生成分析报告\nhikyuu-qlib-analyze report --results-path ./results --output-dir ./reports\n\n# 策略对比\nhikyuu-qlib-analyze compare --strategies strategy1,strategy2 --metric sharpe_ratio\n\n# 可视化结果\nhikyuu-qlib-analyze plot --results-path ./results --type equity_curve\n```\n\n### 3.3 核心类接口设计\n\n#### 3.3.1 Hikyuu初始化接口\n\n```python\nclass HikyuuInitializer:\n    \"\"\"\n    Hikyuu框架初始化类\n    \"\"\"\n    def __init__(self, config_file: str = None):\n        \"\"\"\n        初始化Hikyuu框架\n        \n        Args:\n            config_file: 配置文件路径，默认为 ~/.hikyuu/hikyuu.ini\n        \"\"\"\n        pass\n    \n    def initialize(self, stock_list: list = None, ktype_list: list = None,\n                  preload_num: dict = None, start_spot: bool = False):\n        \"\"\"\n        执行Hikyuu初始化\n        \n        Args:\n            stock_list: 指定加载的股票列表，默认为全部A股\n            ktype_list: 指定加载的K线类型列表，如: ['day', 'week', 'month']\n            preload_num: 预加载参数，如: {'day_max': 100000, 'week_max': 1000}\n            start_spot: 是否启动行情接收，默认为False\n        \"\"\"\n        pass\n```\n\n#### 3.3.2 数据流通接口\n\n```python\nclass HikyuuDataLoader:\n    \"\"\"\n    Hikyuu数据加载器\n    \"\"\"\n    def load_stock_data(self, stock_code: str, query: hikyuu.Query) -> hikyuu.KData:\n        \"\"\"\n        加载单个股票的K线数据\n        \n        Args:\n            stock_code: 股票代码，如 'sh000001'\n            query: 查询对象，指定查询范围和K线类型\n            \n        Returns:\n            KData对象\n        \"\"\"\n        pass\n    \n    def extract_to_dataframe(self, kdata: hikyuu.KData) -> pd.DataFrame:\n        \"\"\"\n        将KData转换为Pandas DataFrame\n        \n        Args:\n            kdata: KData对象\n            \n        Returns:\n            MultiIndex DataFrame (datetime, instrument)\n        \"\"\"\n        pass\n\nclass QlibDataConverter:\n    \"\"\"\n    Qlib数据转换器，将Hikyuu HDF5数据转换为Qlib .bin格式\n    \"\"\"\n    def __init__(self, qlib_dir: str, region: str = \"REG_CN\"):\n        \"\"\"\n        初始化Qlib数据转换器\n        \n        Args:\n            qlib_dir: Qlib数据目录\n            region: 市场区域，中国市场使用REG_CN\n        \"\"\"\n        self.qlib_dir = qlib_dir\n        self.region = region\n    \n    def convert_hikyuu_to_qlib(self, stock_data: dict, fields: list):\n        \"\"\"\n        将Hikyuu数据转换为Qlib格式\n        \n        Args:\n            stock_data: 股票数据字典 {stock_code: DataFrame}\n            fields: 字段列表 ['open', 'high', 'low', 'close', 'volume', 'factor']\n        \"\"\"\n        # 按照Qlib的dump_bin.py期望的结构组织数据\n        # 每只股票作为单独的目录，每个字段作为单独的.bin文件\n        for stock_code, df in stock_data.items():\n            stock_dir = os.path.join(self.qlib_dir, stock_code)\n            os.makedirs(stock_dir, exist_ok=True)\n            \n            for field in fields:\n                if field in df.columns:\n                    field_data = df[field].values\n                    field_file = os.path.join(stock_dir, f\"{field}.bin\")\n                    field_data.tofile(field_file)\n    \n    def create_qlib_instrument_config(self, stock_codes: list):\n        \"\"\"\n        创建Qlib标的配置文件\n        \n        Args:\n            stock_codes: 股票代码列表\n        \"\"\"\n        instrument_config = {\n            \"market\": self.region,\n            \"instrument_list\": stock_codes\n        }\n        \n        config_file = os.path.join(self.qlib_dir, \"instruments\", f\"{self.region.lower()}.txt\")\n        os.makedirs(os.path.dirname(config_file), exist_ok=True)\n        \n        with open(config_file, 'w') as f:\n            for stock_code in stock_codes:\n                f.write(f\"{stock_code}\\n\")\n    \n    def create_qlib_calendar_config(self, trading_days: list):\n        \"\"\"\n        创建Qlib交易日历配置文件\n        \n        Args:\n            trading_days: 交易日列表 [datetime, ...]\n        \"\"\"\n        calendar_file = os.path.join(self.qlib_dir, \"calendars\", \"day.txt\")\n        os.makedirs(os.path.dirname(calendar_file), exist_ok=True)\n        \n        with open(calendar_file, 'w') as f:\n            for day in trading_days:\n                f.write(f\"{day.strftime('%Y-%m-%d')}\\n\")\n\nclass QlibDataProcessor:\n    \"\"\"\n    Qlib数据处理器，使用Qlib的处理器进行特征工程\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        初始化数据处理器\n        \"\"\"\n        self.processors = []\n    \n    def add_processor(self, processor):\n        \"\"\"\n        添加数据处理器\n        \n        Args:\n            processor: Qlib处理器实例\n        \"\"\"\n        self.processors.append(processor)\n    \n    def process_data(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        处理数据\n        \n        Args:\n            df: 输入数据\n            \n        Returns:\n            处理后的数据\n        \"\"\"\n        for processor in self.processors:\n            df = processor(df)\n        return df\n```\n\n#### 3.3.3 模型训练接口\n\n```python\nclass QlibInitializer:\n    \"\"\"\n    Qlib初始化器\n    \"\"\"\n    def __init__(self, provider_uri: str, region: str = \"REG_CN\"):\n        \"\"\"\n        初始化Qlib框架\n        \n        Args:\n            provider_uri: 数据提供者URI，指向Qlib数据目录\n            region: 市场区域，中国市场使用REG_CN\n        \"\"\"\n        self.provider_uri = provider_uri\n        self.region = region\n        self.initialized = False\n    \n    def initialize(self, redis_host: str = None, redis_port: int = None,\n                 expression_cache: str = None, dataset_cache: str = None):\n        \"\"\"\n        执行Qlib初始化\n        \n        Args:\n            redis_host: Redis主机地址\n            redis_port: Redis端口\n            expression_cache: 表达式缓存路径\n            dataset_cache: 数据集缓存路径\n        \"\"\"\n        import qlib\n        \n        qlib.init(\n            provider_uri=self.provider_uri,\n            region=self.region,\n            redis_host=redis_host,\n            redis_port=redis_port,\n            expression_cache=expression_cache,\n            dataset_cache=dataset_cache\n        )\n        self.initialized = True\n\nclass QlibWorkflowManager:\n    \"\"\"\n    Qlib工作流管理器\n    \"\"\"\n    def __init__(self, qlib_initializer: QlibInitializer):\n        \"\"\"\n        初始化工作流管理器\n        \n        Args:\n            qlib_initializer: Qlib初始化器\n        \"\"\"\n        self.qlib_initializer = qlib_initializer\n    \n    def create_workflow_config(self, model_config: dict, dataset_config: dict,\n                           experiment_name: str) -> dict:\n        \"\"\"\n        创建工作流配置\n        \n        Args:\n            model_config: 模型配置\n            dataset_config: 数据集配置\n            experiment_name: 实验名称\n            \n        Returns:\n            工作流配置字典\n        \"\"\"\n        workflow_config = {\n            \"qlib_init\": {\n                \"provider_uri\": self.qlib_initializer.provider_uri,\n                \"region\": self.qlib_initializer.region\n            },\n            \"market\": {\n                \"market\": self.qlib_initializer.region,\n                \"benchmark\": \"SH000300\",\n                \"trade_unit\": 100,\n                \"limit_threshold\": 0.099\n            },\n            \"data_handler_config\": {\n                \"start_time\": dataset_config.get(\"start_time\", \"2010-01-01\"),\n                \"end_time\": dataset_config.get(\"end_time\", \"2023-12-31\"),\n                \"fit_start_time\": dataset_config.get(\"fit_start_time\", \"2010-01-01\"),\n                \"fit_end_time\": dataset_config.get(\"fit_end_time\", \"2020-12-31\"),\n                \"instruments\": dataset_config.get(\"instruments\", [\"SH000001\", \"SZ000001\"]),\n                \"learn_processors\": [\n                    {\"class\": \"DropnaProcessor\"},\n                    {\"class\": \"ZscoreNorm\", \"fields_group\": \"feature\"}\n                ],\n                \"process_type\": \"independent\"\n            },\n            \"model\": model_config,\n            \"dataset\": {\n                \"class\": \"DatasetH\",\n                \"module_path\": \"qlib.data.dataset\",\n                \"kwargs\": {\n                    \"handler\": {\n                        \"class\": \"Alpha158\",\n                        \"module_path\": \"qlib.contrib.data.handler\",\n                        \"kwargs\": dataset_config\n                    }\n                }\n            },\n            \"record\": {\n                \"class\": \"SignalRecord\",\n                \"module_path\": \"qlib.workflow.record\"\n            }\n        }\n        \n        return workflow_config\n    \n    def run_workflow(self, workflow_config: dict, experiment_name: str):\n        \"\"\"\n        运行工作流\n        \n        Args:\n            workflow_config: 工作流配置\n            experiment_name: 实验名称\n        \"\"\"\n        import qlib\n        from qlib.workflow import R\n        \n        if not self.qlib_initializer.initialized:\n            self.qlib_initializer.initialize()\n        \n        with R.start(experiment_name=experiment_name):\n            # 生成工作流YAML文件\n            workflow_file = f\"{experiment_name}_workflow.yaml\"\n            with open(workflow_file, 'w') as f:\n                import yaml\n                yaml.dump(workflow_config, f)\n            \n            # 使用qrun执行工作流\n            import subprocess\n            subprocess.run([\"qrun\", workflow_file], check=True)\n    \n    def train_model(self, model_config: dict, dataset_config: dict,\n                   experiment_name: str) -> str:\n        \"\"\"\n        训练Qlib模型\n        \n        Args:\n            model_config: 模型配置，包含模型类型、参数等\n            dataset_config: 数据集配置，包含特征、标签等\n            experiment_name: 实验名称\n            \n        Returns:\n            模型路径\n        \"\"\"\n        workflow_config = self.create_workflow_config(model_config, dataset_config, experiment_name)\n        self.run_workflow(workflow_config, experiment_name)\n        \n        # 返回模型路径\n        return f\"./mlflow/{experiment_name}/artifacts/model.pkl\"\n    \n    def predict(self, model_path: str, data_config: dict) -> str:\n        \"\"\"\n        使用训练好的模型进行预测\n        \n        Args:\n            model_path: 模型路径\n            data_config: 预测数据配置\n            \n        Returns:\n            预测结果文件路径\n        \"\"\"\n        import qlib\n        from qlib.workflow import R\n        \n        # 加载模型\n        model = qlib.model.load(model_path)\n        \n        # 准备数据\n        dataset = qlib.data.Dataset(\n            handler=qlib.data.handler.Alpha158(**data_config)\n        )\n        \n        # 进行预测\n        with R.start(experiment_name=\"prediction\"):\n            pred = model.predict(dataset)\n            pred_file = f\"./results/pred_{R.get_recorder().id}.pkl\"\n            pred.to_pickle(pred_file)\n        \n        return pred_file\n```\n\n#### 3.3.4 信号转换接口\n\n```python\nclass QlibPredictionParser:\n    \"\"\"\n    Qlib预测结果解析器\n    \"\"\"\n    def __init__(self, prediction_path: str):\n        \"\"\"\n        初始化预测结果解析器\n        \n        Args:\n            prediction_path: Qlib预测结果文件路径\n        \"\"\"\n        self.prediction_path = prediction_path\n        self.prediction_data = None\n    \n    def load_prediction(self):\n        \"\"\"\n        加载预测结果\n        \"\"\"\n        import pandas as pd\n        self.prediction_data = pd.read_pickle(self.prediction_path)\n        \n        # 确保数据格式正确：MultiIndex(datetime, instrument) + 预测分数列\n        if not isinstance(self.prediction_data.index, pd.MultiIndex):\n            raise ValueError(\"预测结果必须包含MultiIndex(datetime, instrument)\")\n    \n    def get_prediction_scores(self, stock_code: str = None,\n                          start_date: str = None, end_date: str = None):\n        \"\"\"\n        获取预测分数\n        \n        Args:\n            stock_code: 股票代码，None表示所有股票\n            start_date: 开始日期，None表示最早日期\n            end_date: 结束日期，None表示最晚日期\n            \n        Returns:\n            预测分数DataFrame\n        \"\"\"\n        if self.prediction_data is None:\n            self.load_prediction()\n        \n        data = self.prediction_data.copy()\n        \n        # 按股票代码过滤\n        if stock_code is not None:\n            data = data[data.index.get_level_values('instrument') == stock_code]\n        \n        # 按日期过滤\n        if start_date is not None:\n            data = data[data.index.get_level_values('datetime') >= start_date]\n        \n        if end_date is not None:\n            data = data[data.index.get_level_values('datetime') <= end_date]\n        \n        return data\n\nclass CustomSG_QlibFactor(hikyuu.SignalBase):\n    \"\"\"\n    自定义Qlib因子信号指示器\n    \"\"\"\n    def __init__(self, prediction_path: str, top_k: int = 10,\n                 threshold: float = 0.5, normalization: str = \"zscore\"):\n        \"\"\"\n        初始化信号指示器\n        \n        Args:\n            prediction_path: Qlib预测结果文件路径\n            top_k: 选股数量\n            threshold: 信号阈值\n            normalization: 标准化方法，\"zscore\"或\"minmax\"\n        \"\"\"\n        super().__init__()\n        self.prediction_parser = QlibPredictionParser(prediction_path)\n        self.top_k = top_k\n        self.threshold = threshold\n        self.normalization = normalization\n        self.prediction_scores = None\n    \n    def _calculate(self):\n        \"\"\"\n        计算信号，继承自SignalBase的抽象方法\n        \"\"\"\n        # 获取当前股票和日期的预测分数\n        current_datetime = self.get_datetime()\n        current_stock = self.get_stock()\n        \n        # 加载预测分数\n        if self.prediction_scores is None:\n            self.prediction_scores = self.prediction_parser.get_prediction_scores()\n        \n        # 获取当前股票在当前日期的预测分数\n        try:\n            score = self.prediction_scores.loc[(current_datetime, current_stock)].iloc[0]\n        except (KeyError, IndexError):\n            # 如果没有对应的预测分数，返回0信号\n            self._set_value(0)\n            return\n        \n        # 标准化预测分数\n        if self.normalization == \"zscore\":\n            # 使用Z-Score标准化\n            mean_score = self.prediction_scores.mean()\n            std_score = self.prediction_scores.std()\n            if std_score > 0:\n                normalized_score = (score - mean_score) / std_score\n            else:\n                normalized_score = 0\n        elif self.normalization == \"minmax\":\n            # 使用Min-Max标准化\n            min_score = self.prediction_scores.min()\n            max_score = self.prediction_scores.max()\n            if max_score > min_score:\n                normalized_score = (score - min_score) / (max_score - min_score)\n            else:\n                normalized_score = 0.5\n        else:\n            normalized_score = score\n        \n        # 生成信号\n        if normalized_score > self.threshold:\n            # 基于Top-K选股逻辑\n            # 获取当前日期所有股票的预测分数\n            daily_scores = self.prediction_scores.loc[current_datetime]\n            # 按分数降序排序\n            daily_scores = daily_scores.sort_values(ascending=False)\n            # 获取Top-K股票\n            top_k_stocks = daily_scores.head(self.top_k).index.tolist()\n            \n            # 如果当前股票在Top-K中，生成买入信号\n            if current_stock in top_k_stocks:\n                self._set_value(1)  # 买入信号\n            else:\n                self._set_value(0)  # 无信号\n        else:\n            self._set_value(0)  # 无信号\n\nclass SignalRecordManager:\n    \"\"\"\n    信号记录管理器，使用Qlib的SignalRecord和PortAnaRecord\n    \"\"\"\n    def __init__(self, experiment_name: str):\n        \"\"\"\n        初始化信号记录管理器\n        \n        Args:\n            experiment_name: 实验名称\n        \"\"\"\n        self.experiment_name = experiment_name\n        self.signal_records = []\n        self.portfolio_records = []\n    \n    def add_signal_record(self, prediction_df: pd.DataFrame):\n        \"\"\"\n        添加信号记录\n        \n        Args:\n            prediction_df: 预测结果DataFrame\n        \"\"\"\n        from qlib.workflow.record import SignalRecord\n        \n        record = SignalRecord(\n            pred=prediction_df,\n            label=None,  # 可选标签\n            recorder_id=len(self.signal_records)\n        )\n        self.signal_records.append(record)\n    \n    def add_portfolio_record(self, portfolio_df: pd.DataFrame):\n        \"\"\"\n        添加投资组合记录\n        \n        Args:\n            portfolio_df: 投资组合DataFrame\n        \"\"\"\n        from qlib.workflow.record import PortAnaRecord\n        \n        record = PortAnaRecord(\n            portfolio=portfolio_df,\n            recorder_id=len(self.portfolio_records)\n        )\n        self.portfolio_records.append(record)\n    \n    def get_signal_analysis(self):\n        \"\"\"\n        获取信号分析结果\n        \n        Returns:\n            信号分析结果\n        \"\"\"\n        if not self.signal_records:\n            return None\n        \n        # 合并所有信号记录\n        all_signals = pd.concat([record.pred for record in self.signal_records])\n        \n        return {\n            \"signal_count\": len(all_signals),\n            \"signal_distribution\": all_signals.describe(),\n            \"average_signal\": all_signals.mean(),\n            \"signal_volatility\": all_signals.std()\n        }\n\nclass SignalConverter:\n    \"\"\"\n    信号转换器\n    \"\"\"\n    def __init__(self, prediction_path: str):\n        \"\"\"\n        初始化信号转换器\n        \n        Args:\n            prediction_path: Qlib预测结果文件路径\n        \"\"\"\n        self.prediction_parser = QlibPredictionParser(prediction_path)\n        self.record_manager = SignalRecordManager(\"signal_conversion\")\n    \n    def convert_prediction_to_signals(self, output_format: str = \"CSV\") -> str:\n        \"\"\"\n        将Qlib预测结果转换为Hikyuu信号格式\n        \n        Args:\n            output_format: 输出格式 (CSV/JSON)\n            \n        Returns:\n            信号文件路径\n        \"\"\"\n        # 加载预测结果\n        self.prediction_parser.load_prediction()\n        prediction_data = self.prediction_parser.prediction_data\n        \n        # 添加信号记录\n        self.record_manager.add_signal_record(prediction_data)\n        \n        # 转换为Hikyuu信号格式\n        # MultiIndex (datetime, instrument) -> 列格式\n        signal_df = prediction_data.reset_index()\n        \n        # 创建输出目录\n        os.makedirs(\"./signals\", exist_ok=True)\n        \n        # 根据输出格式保存\n        if output_format.upper() == \"CSV\":\n            output_file = \"./signals/hikyuu_signals.csv\"\n            signal_df.to_csv(output_file, index=False)\n        elif output_format.upper() == \"JSON\":\n            output_file = \"./signals/hikyuu_signals.json\"\n            signal_df.to_json(output_file, orient=\"records\")\n        else:\n            raise ValueError(f\"不支持的输出格式: {output_format}\")\n        \n        return output_file\n```\n\n#### 3.3.5 回测执行接口\n\n```python\nclass HikyuuBacktestEngine:\n    \"\"\"\n    Hikyuu回测引擎\n    \"\"\"\n    def create_trade_manager(self, init_cash: float = 1000000) -> hikyuu.TradeManager:\n        \"\"\"\n        创建交易管理器\n        \n        Args:\n            init_cash: 初始资金\n            \n        Returns:\n            TradeManager对象\n        \"\"\"\n        pass\n    \n    def create_trading_system(self, sg: hikyuu.SignalBase, mm: hikyuu.MoneyManagerBase,\n                           st: hikyuu.StoplossBase = None, tp: hikyuu.StoplossBase = None,\n                           sp: hikyuu.SlippageBase = None) -> hikyuu.SystemBase:\n        \"\"\"\n        创建交易系统\n        \n        Args:\n            sg: 信号指示器\n            mm: 资金管理策略\n            st: 止损策略\n            tp: 止盈策略（注意：使用ST_前缀）\n            sp: 移滑价差算法\n            \n        Returns:\n            SystemBase对象\n        \"\"\"\n        pass\n    \n    def run_backtest(self, system: hikyuu.SystemBase, stock_code: str,\n                    query: hikyuu.Query) -> hikyuu.Performance:\n        \"\"\"\n        执行回测\n        \n        Args:\n            system: 交易系统\n            stock_code: 股票代码\n            query: 查询对象\n            \n        Returns:\n            Performance对象\n        \"\"\"\n        pass\n```\n\n## 4. 数据架构\n\n### 4.1 数据存储策略\n\n- **Hikyuu HDF5数据**: 存储原始行情数据和复权因子\n- **Qlib .bin数据**: 存储Qlib格式的特征数据\n- **配置文件**: Hikyuu INI格式和Qlib YAML格式的系统配置\n- **预测结果文件**: 存储Qlib模型输出的pred.pkl文件\n- **信号文件**: 存储转换后的Hikyuu信号格式\n\n### 4.2 数据流设计\n\n```mermaid\ngraph LR\n    A[Hikyuu HDF5数据] --> B[HikyuuDataLoader]\n    B --> C[Qlib Dataset]\n    C --> D[特征计算]\n    D --> E[模型训练]\n    E --> F[预测结果pred.pkl]\n    F --> G[信号转换器]\n    G --> H[Hikyuu信号文件]\n    H --> I[Hikyuu回测引擎]\n    I --> J[回测报告]\n    \n    K[配置文件config.yaml] --> B\n    K --> E\n    K --> G\n    K --> I\n```\n\n### 4.3 数据一致性\n\n- **强一致性场景**: 数据加载过程中的格式转换和验证\n- **最终一致性场景**: 模型训练和预测结果的异步更新\n- **版本控制**: 配置文件和实验记录的版本管理\n\n## 5. 关键集成设计\n\n### 5.1 Hikyuu与Qlib集成方案\n\n#### 5.1.1 数据流通集成\n\n- **数据源**: Hikyuu HDF5格式存储的行情数据，通过hikyuu.StockManager和hikyuu.KData访问\n- **数据目标**: Qlib .bin格式存储的特征数据，通过qlib.init()和qlib.data访问\n- **转换过程**:\n  1. 使用hikyuu.StockManager获取证券列表和基本信息\n  2. 使用hikyuu.KData获取K线数据，应用复权因子\n  3. 转换为Qlib所需的MultiIndex DataFrame格式\n  4. 使用qlib.data.D.save()生成Qlib .bin格式文件\n\n#### 5.1.2 特征计算集成\n\n- **基础特征**: 基于Hikyuu的hikyuu.indicator模块计算EMA、MACD、RSI等技术指标\n- **特征表达式**: 使用Qlib的表达式引擎定义特征计算逻辑\n- **特征编排**: 支持用户自定义特征组合和参数调整，通过YAML配置文件管理\n\n#### 5.1.3 信号转换集成\n\n- **输入格式**: Qlib pred.pkl文件（使用qlib.workflow.R.read_pred()读取）\n- **输出格式**: Hikyuu信号格式（CSV/JSON，可被hikyuu交易系统使用）\n- **转换规则**:\n  1. 支持Top-K选股策略（基于预测分数排序）\n  2. 支持择时信号映射（将预测分数转换为买入/卖出信号）\n  3. 支持阈值过滤和信号标准化\n\n#### 5.1.4 Hikyuu回测集成\n\n- **TradeManager集成**: 使用hikyuu.TradeManager进行交易账户管理\n- **交易系统组件集成**:\n  - 信号指示器（SG）：使用自定义SG_QlibFactor将Qlib预测信号转换为Hikyuu交易信号\n  - 资金管理策略（MM）：使用hikyuu.trade_sys.MM_FixedCount、hikyuu.trade_sys.MM_FixedRisk等\n  - 止损止盈策略（ST/TP）：使用hikyuu.trade_sys.ST_FixedPercent、hikyuu.trade_sys.TP_FixedPercent等\n  - 移滑价差算法（SP）：使用hikyuu.trade_sys.cost_func，支持沪深A股等多种交易成本计算\n- **Performance统计集成**: 使用hikyuu.Performance进行回测绩效分析\n- **投资组合集成**: 使用hikyuu.trade_sys.PF和hikyuu.trade_sys.SYS_WalkForward支持多策略组合和滚动交易系统\n\n### 5.2 配置驱动设计\n\n#### 5.2.1 配置结构\n\n**Hikyuu INI配置** (hikyuu.ini):\n\n```ini\n[hikyuu]\ntmpdir = ./data/hikyuu\ndatadir = ./data/hikyuu\nquotation_server = ipc:///tmp/hikyuu_real.ipc\nload_history_finance = True\nload_stock_weight = True\n\n[baseinfo]\ntype = sqlite3\ndb = stock.db\n\n[kdata]\ntype = hdf5\ndir = ./data/hikyuu\n\n[preload]\nday = true\nday_max = 4096\nweek = true\nweek_max = 1000\n```\n\n**Qlib YAML配置** (config.yaml):\n\n```yaml\n# 数据配置\ndata:\n  hikyuu_data_dir: \"./data/hikyuu\"\n  market: \"SH\"\n  instruments: [\"000001\", \"600000\"]\n  start_time: \"2020-01-01\"\n  end_time: \"2023-12-31\"\n  \n# 模型配置\nmodel:\n  type: \"LGBModel\"\n  features: [\"EMA5\", \"EMA10\", \"MACD\", \"RSI\"]\n  training_window: \"252D\"\n  experiment_name: \"default_exp\"\n  \n# 策略配置\nstrategy:\n  signal_format: \"CSV\"\n  top_k: 10\n  threshold: 0.5\n  \n# 回测配置\nbacktest:\n  initial_cash: 1000000\n  start_date: \"2021-01-01\"\n  end_date: \"2023-12-31\"\n  cost_commission: 0.001\n```\n\n#### 5.2.2 配置管理\n\n- **统一配置**: 所有模块参数统一在config.yaml中管理\n- **参数验证**: 配置加载时进行参数有效性验证\n- **版本管理**: 支持配置文件的版本控制和回滚\n\n### 5.3 端到端流程设计\n\n#### 5.3.1 完整流程图\n\n```mermaid\ngraph TB\n    A[用户配置] --> B[数据流通模块]\n    B --> C[加载Hikyuu数据]\n    C --> D[转换为Qlib格式]\n    D --> E[特征计算]\n    E --> F[机器学习建模模块]\n    F --> G[模型训练]\n    G --> H[模型预测]\n    H --> I[策略执行模块]\n    I --> J[信号转换]\n    J --> K[Hikyuu回测]\n    K --> L[回测报告]\n    L --> M[复盘分析模块]\n    M --> N[可视化展示]\n    N --> O[策略优化]\n    \n    P[配置管理] --> B\n    P --> F\n    P --> I\n```\n\n#### 5.3.2 模块协作关系\n\n1. **数据流通模块**为机器学习建模模块提供标准化的训练数据\n2. **机器学习建模模块**为策略执行模块提供预测信号\n3. **策略执行模块**为复盘分析模块提供回测结果\n4. **配置管理模块**为所有模块提供统一的配置管理\n5. **复盘分析模块**为用户提供决策支持和优化建议\n\n## 6. 技术栈选择理由\n\n### 6.1 核心技术栈\n\n- **Python**: 主要开发语言，丰富的金融和机器学习库生态\n- **Hikyuu**: 成熟的量化交易框架，提供完整的回测和执行引擎\n- **Qlib**: 微软开源的AI量化平台，提供强大的机器学习能力\n- **Pandas**: 数据处理和分析的核心库\n- **HDF5**: 高效的金融数据存储格式\n- **Click**: 命令行工具框架，提供参数验证和自动帮助文档生成\n\n### 6.2 辅助技术栈\n\n- **PyYAML**: 配置文件解析和管理\n- **Matplotlib**: 回测结果可视化\n- **LightGBM**: 默认的机器学习模型\n- **NumPy**: 数值计算支持\n- **ConfigParser**: Hikyuu INI配置文件解析\n\n### 6.3 选型理由\n\n- **Python**: 金融量化领域的标准语言，社区活跃，库生态完善\n- **Hikyuu**: 专门针对中文市场设计的量化框架，支持完整的交易系统，包括SYS_WalkForward滚动寻优系统\n- **Qlib**: 企业级的AI量化平台，提供端到端的机器学习解决方案\n- **HDF5**: 高性能的金融数据存储格式，支持大规模历史数据\n- **Click**: 成熟的命令行工具框架，Hikyuu已采用类似方案\n- **LightGBM**: 高效的梯度提升树算法，适合金融时序预测\n\n## 7. 高级功能架构设计\n\n### 7.1 滚动交易系统(SYS_WalkForward)架构\n\n#### 7.1.1 SYS_WalkForward工作原理\n\n```python\nclass SYS_WalkForwardIntegration:\n    \"\"\"\n    Hikyuu滚动寻优系统集成类\n    \"\"\"\n    def __init__(self, model_paths: list, train_len: int = 100, test_len: int = 20):\n        \"\"\"\n        初始化滚动寻优系统\n        \n        Args:\n            model_paths: Qlib模型路径列表，对应多个候选系统\n            train_len: 训练期长度，默认100天\n            test_len: 测试期长度，默认20天\n        \"\"\"\n        self.model_paths = model_paths\n        self.train_len = train_len\n        self.test_len = test_len\n        self.system_list = []\n        self.walk_forward_sys = None\n    \n    def create_candidate_systems(self, tm: hikyuu.TradeManager):\n        \"\"\"\n        创建基于不同Qlib模型的候选交易系统\n        \n        Args:\n            tm: 交易管理器\n        \"\"\"\n        self.system_list = []\n        for model_path in self.model_paths:\n            # 创建自定义信号指示器\n            sg = CustomSG_QlibFactor(model_path)\n            # 创建资金管理策略\n            mm = hikyuu.MM_FixedCount(1000)\n            # 创建止损策略\n            st = hikyuu.ST_FixedPercent(0.05)\n            # 创建移滑价差算法\n            sp = hikyuu.SP_FixedPercent(0.001)\n            \n            # 创建交易系统\n            sys = hikyuu.SYS_Simple(sg=sg, mm=mm, st=st, sp=sp)\n            self.system_list.append(sys)\n    \n    def create_walk_forward_system(self, tm: hikyuu.TradeManager,\n                                 se: hikyuu.SelectorBase = None):\n        \"\"\"\n        创建滚动寻优系统\n        \n        Args:\n            tm: 交易管理器\n            se: 选择器，默认使用SE_PerformanceOptimal\n        \"\"\"\n        if se is None:\n            # 使用默认选择器：基于\"帐户平均年收益率%\"最大选择\n            se = hikyuu.SE_PerformanceOptimal(key=\"帐户平均年收益率%\", mode=0)\n        \n        self.walk_forward_sys = hikyuu.SYS_WalkForward(\n            sys_list=self.system_list,\n            tm=tm,\n            train_len=self.train_len,\n            test_len=self.test_len,\n            se=se\n        )\n    \n    def run_backtest(self, stock: hikyuu.Stock, query: hikyuu.Query):\n        \"\"\"\n        执行滚动寻优回测\n        \n        Args:\n            stock: 股票对象\n            query: 查询对象\n            \n        Returns:\n            回测结果\n        \"\"\"\n        if self.walk_forward_sys is None:\n            raise ValueError(\"滚动寻优系统未初始化\")\n        \n        return self.walk_forward_sys.run(stock, query)\n```\n\n#### 7.1.2 自定义选择器设计\n\n```python\nclass CustomSelector(hikyuu.SelectorBase):\n    \"\"\"\n    自定义系统选择器\n    \"\"\"\n    def __init__(self, key: str = \"夏普比率\", mode: int = 0):\n        \"\"\"\n        初始化选择器\n        \n        Args:\n            key: 选择依据的绩效指标\n            mode: 选择模式（0：最大值，1：最小值）\n        \"\"\"\n        super().__init__()\n        self.key = key\n        self.mode = mode\n    \n    def _calculate(self):\n        \"\"\"\n        计算选择结果，继承自SelectorBase的抽象方法\n        \"\"\"\n        # 实现自定义选择逻辑\n        pass\n```\n\n### 7.2 批量系统分析架构\n\n#### 7.2.1 批量系统分析设计\n\n```python\nclass BatchSystemAnalyzer:\n    \"\"\"\n    批量系统分析器\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        初始化批量系统分析器\n        \"\"\"\n        self.system_list = []\n        self.stock_list = []\n        self.results = []\n    \n    def add_system(self, sg: hikyuu.SignalBase, tm: hikyuu.TradeManager):\n        \"\"\"\n        添加交易系统\n        \n        Args:\n            sg: 信号指示器\n            tm: 交易管理器\n        \"\"\"\n        mm = hikyuu.MM_FixedCount(1000)\n        st = hikyuu.ST_FixedPercent(0.05)\n        sp = hikyuu.SP_FixedPercent(0.001)\n        \n        sys = hikyuu.SYS_Simple(sg=sg, mm=mm, st=st, sp=sp)\n        self.system_list.append(sys)\n    \n    def add_stock(self, stock_code: str):\n        \"\"\"\n        添加股票\n        \n        Args:\n            stock_code: 股票代码\n        \"\"\"\n        sm = hikyuu.StockManager.instance()\n        self.stock_list.append(sm[stock_code])\n    \n    def run_analysis(self, query: hikyuu.Query):\n        \"\"\"\n        执行批量系统分析\n        \n        Args:\n            query: 查询对象\n            \n        Returns:\n            分析结果\n        \"\"\"\n        if len(self.system_list) != len(self.stock_list):\n            raise ValueError(\"系统列表和股票列表长度不匹配\")\n        \n        # 使用Hikyuu的analysisSystemList进行批量分析\n        self.results = hikyuu.analysisSystemList(\n            self.system_list,\n            self.stock_list,\n            query\n        )\n        return self.results\n    \n    def get_performance_summary(self):\n        \"\"\"\n        获取绩效摘要\n        \n        Returns:\n            绩效摘要DataFrame\n        \"\"\"\n        if not self.results:\n            return None\n        \n        summary_data = []\n        for result in self.results:\n            summary_data.append({\n                '股票代码': result.market_code,\n                '股票名称': result.name,\n                '绩效指标': result.values\n            })\n        \n        return pd.DataFrame(summary_data)\n```\n\n### 7.3 可视化架构设计\n\n#### 7.3.1 系统绩效可视化\n\n```python\nclass SystemVisualizer:\n    \"\"\"\n    系统可视化器\n    \"\"\"\n    @staticmethod\n    def plot_system_performance(sys: hikyuu.SystemBase,\n                              ref_stk: hikyuu.Stock = None):\n        \"\"\"\n        绘制系统绩效曲线\n        \n        Args:\n            sys: 交易系统\n            ref_stk: 参考股票，默认为沪深300\n        \"\"\"\n        if ref_stk is None:\n            sm = hikyuu.StockManager.instance()\n            ref_stk = sm['sh000300']\n        \n        # 使用Hikyuu的sys_performance函数\n        from hikyuu.interactive import sys_performance\n        sys_performance(sys, ref_stk=ref_stk)\n    \n    @staticmethod\n    def plot_system_heatmap(sys: hikyuu.SystemBase):\n        \"\"\"\n        绘制系统收益热力图\n        \n        Args:\n            sys: 交易系统\n        \"\"\"\n        # 使用Hikyuu的sys_heatmap函数\n        from hikyuu.interactive import sys_heatmap\n        sys_heatmap(sys)\n    \n    @staticmethod\n    def plot_batch_system_comparison(results: list):\n        \"\"\"\n        绘制批量系统对比图\n        \n        Args:\n            results: 批量系统分析结果\n        \"\"\"\n        # 实现多系统绩效对比可视化\n        pass\n```\n\n### 7.4 命令行工具打包架构\n\n#### 7.4.1 setup.py配置\n\n```python\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='hikyuu-qlib',\n    version='1.0.0',\n    packages=find_packages(),\n    install_requires=[\n        'click>=8.0.0',\n        'pyyaml>=5.4.0',\n        'pandas>=1.3.0',\n        'numpy>=1.20.0',\n        'matplotlib>=3.3.0',\n        'lightgbm>=3.2.0',\n        'hikyuu>=2.2.0',\n        'qlib>=0.8.0',\n        'configparser>=5.0.0',\n    ],\n    entry_points={\n        'console_scripts': [\n            'hikyuu-qlib-config=hikyuu_qlib.cli.config:cli',\n            'hikyuu-qlib-data=hikyuu_qlib.cli.data:cli',\n            'hikyuu-qlib-train=hikyuu_qlib.cli.train:cli',\n            'hikyuu-qlib-backtest=hikyuu_qlib.cli.backtest:cli',\n            'hikyuu-qlib-analyze=hikyuu_qlib.cli.analyze:cli',\n        ]\n    },\n    author='Hikyuu Qlib Team',\n    author_email='team@hikyuu-qlib.org',\n    description='Hikyuu × Qlib 个人量化工作站',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/hikyuu-qlib/hikyuu-qlib',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Financial and Insurance Industry',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Topic :: Office/Business :: Financial',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n    ],\n    python_requires='>=3.8',\n)\n```\n\n## 7. 组件职责划分\n\n### 7.1 数据流通模块\n\n- **HikyuuStockManagerIntegration**: 负责使用hikyuu.StockManager读取Hikyuu数据\n- **QlibDataConverter**: 负责将Hikyuu KData转换为Qlib格式的数据\n- **QlibFeatureCalculator**: 负责基于Hikyuu技术指标计算Qlib特征\n- **QlibDatasetBuilder**: 负责构建Qlib Dataset并生成.bin格式数据\n- **DataValidator**: 负责数据完整性和一致性校验\n\n### 7.2 机器学习建模模块\n\n- **QlibWorkflowManager**: 负责使用qrun命令和YAML配置管理模型训练工作流\n- **QlibModelTrainer**: 负责使用qlib.workflow训练LGBModel、MLP、LSTM等模型\n- **QlibModelPredictor**: 负责使用训练好的模型进行预测并生成pred.pkl文件\n- **QlibRecorderIntegration**: 负责集成Qlib Recorder进行实验记录和管理\n- **QlibModelAnalysis**: 负责提供IC分析、风险分析、累积收益分析功能\n\n### 7.3 策略执行模块\n\n- **QlibSignalParser**: 负责解析Qlib pred.pkl文件中的预测结果\n- **HikyuuSignalGenerator**: 负责将预测结果转换为Hikyuu交易信号\n- **HikyuuTradeManagerIntegration**: 负责使用hikyuu.TradeManager进行交易账户管理\n- **HikyuuSystemComposer**: 负责构建Hikyuu交易系统组件（SG、MM、ST、TP、SP）\n- **HikyuuPortfolioManager**: 负责使用hikyuu.trade_sys进行投资组合管理\n- **HikyuuPerformanceAnalyzer**: 负责使用hikyuu.Performance分析回测结果\n\n### 7.4 配置管理模块\n\n- **ConfigBridge**: 负责统一管理Hikyuu INI和Qlib YAML配置的桥接层\n- **INIConfigLoader**: 负责Hikyuu INI配置文件的加载和解析\n- **YAMLConfigLoader**: 负责Qlib YAML配置文件的加载和解析\n- **QlibConfigValidator**: 负责Qlib相关配置参数的验证\n- **HikyuuConfigValidator**: 负责Hikyuu相关配置参数的验证\n- **ConfigManager**: 负责配置的版本管理和更新\n- **EnvironmentSetup**: 负责Hikyuu和Qlib环境初始化和配置\n\n### 7.5 复盘分析模块\n\n- **HikyuuPerformanceAnalyzer**: 负责使用hikyuu.Performance分析回测结果\n- **QlibAnalysisIntegration**: 负责集成Qlib分析功能进行结果评估\n- **HikyuuVisualization**: 负责使用hikyuu.interactive进行结果可视化\n- **StrategyComparator**: 负责多策略对比分析\n- **ReportGenerator**: 负责回测报告的生成\n"},"requirements":{"lastTaskId":"cce2a3a4-5cc9-4797-8fea-e14591c37dd0","lastCheckpointId":"97a1a9409b852f83eb42d9d1a6ab25cf5ed2e575","content":"# 需求规格说明书 - Hikyuu × Qlib 个人量化工作站\n\n## 1. 项目概述\n\n### 1.1 背景\n\n随着人工智能技术在金融领域的快速发展，个人投资者对量化交易工具的需求日益增长。然而，现有的量化工具存在以下痛点：\n\n- 数据获取和处理门槛高\n- 机器学习建模技术复杂\n- 策略验证和执行流程割裂\n- 缺乏端到端的集成解决方案\n\n为了解决这些问题，需要构建一套融合Hikyuu和Qlib优势的个人量化工作站，为个人投资者提供一站式AI建模与策略执行平台。\n\n### 1.2 目标\n\n**业务目标：**\n\n- 为个人独立投资者提供桌面级量化工作站\n- 实现AI建模与策略执行的完整闭环\n- 降低机器学习在量化投资中的应用门槛\n\n**技术目标：**\n\n- 打通Hikyuu数据到Qlib建模的壁垒\n- 实现Qlib预测信号到Hikyuu执行的无缝转换\n- 构建轻量化、易用的配置驱动系统\n\n### 1.3 范围\n\n**包含内容：**\n\n- Hikyuu行情数据到Qlib的数据流通\n- Qlib机器学习建模与预测\n- 预测信号到Hikyuu执行格式的转换\n- Hikyuu内置回测与策略执行\n- 端到端配置管理和示例策略\n\n**不包含内容：**\n\n- 企业级特性（如多用户管理、权限控制等）\n- 实时交易执行（仅支持半自动执行）\n\n### 1.4 开发总约束\n\n**开发工作准则：**\n\n1. **以暗猜接口为耻，以认真查阅为荣**：所有接口设计必须基于现有文档，禁止猜测接口定义\n2. **以模糊执行为耻，以寻求确认为荣**：所有执行步骤必须明确，模糊需求需主动确认\n3. **以盲想业务为耻，以人类确认为荣**：业务需求必须通过用户确认，禁止主观假设\n4. **以创造接口为耻，以复用现有为荣**：优先复用现有接口，避免创造不必要的接口\n5. **以跳过验证为耻，以主动测试为荣**：所有功能必须经过验证，禁止跳过测试\n6. **以破坏架构为耻，以遵循规范为荣**：遵循现有架构规范，禁止破坏系统架构\n7. **以假装理解为耻，以诚实无知为荣**：遇到不理解的问题要诚实承认，禁止假装理解\n8. **以盲目修改为耻，以谨慎重构为荣**：修改代码要谨慎，禁止盲目修改现有功能\n\n## 2. 功能需求\n\n### 2.1 用户角色\n\n| 角色名称 | 描述 | 主要使用场景 |\n|----------|------|------|\n| **量化爱好者** | 想体验机器学习择时/选股，降低数据准备与建模门槛的用户 | 学习AI建模，验证技术指标有效性 |\n| **技术指标型交易者** | 期望自动化处理更多特征，利用AI提升策略效率的用户 | 批量测试技术指标组合，寻找最优参数 |\n| **兼职自营投资者** | 希望快速试验新想法、采信AI信号，但仍保持人工把控的用户 | 快速试验策略，参考AI信号做决策 |\n\n### 2.2 功能清单\n\n#### 2.2.1 数据流通模块\n\n- **需求ID**: FR-001\n- **需求描述**: 提供数据接入向导，指导用户配置Hikyuu数据目录、市场、标的、时间范围\n- **优先级**: 高\n- **验收标准**:\n  - 支持默认日线HDF5数据格式\n  - 提供简易UI或脚本引导配置过程\n  - 配置完成后能自动检测数据完整性\n- **依赖关系**: 无\n\n- **需求ID**: FR-002\n- **需求描述**: 实现HikyuuDataLoader，将Hikyuu行情数据加载到Qlib\n- **优先级**: 高\n- **验收标准**:\n  - 默认加载核心字段（开高低收量额、复权因子等）\n  - 支持可选的增量加载模式\n  - 数据格式转换准确无误\n- **依赖关系**: FR-001\n\n- **需求ID**: FR-003\n- **需求描述**: 提供常用技术指标特征模板\n- **优先级**: 中\n- **验收标准**:\n  - 包含EMA、MACD、RSI、量价等常用指标\n  - 支持YAML/JSON模板自定义参数\n  - 特征计算结果准确\n- **依赖关系**: FR-002\n\n#### 2.2.2 机器学习建模模块\n\n- **需求ID**: FR-004\n- **需求描述**: 提供快速训练脚本，支持一键训练并生成预测结果\n- **优先级**: 高\n- **验收标准**:\n  - 默认使用LGBModel+基础指标数据集\n  - 生成pred.pkl预测文件\n  - 支持命令行参数指定训练窗口\n- **依赖关系**: FR-002\n\n- **需求ID**: FR-005\n- **需求描述**: 实现实验记录功能，记录训练过程和结果\n- **优先级**: 中\n- **验收标准**:\n  - 使用Qlib内置R模块记录参数和指标\n  - 本地存储训练记录\n  - 支持历史实验查询\n- **依赖关系**: FR-004\n\n- **需求ID**: FR-006\n- **需求描述**: 建立约束机制，确保训练可复现\n- **优先级**: 中\n- **验收标准**:\n  - 预设训练资源上限和评估指标阈值\n  - 记录数据版本与特征编排\n  - 支持实验条件复现\n- **依赖关系**: FR-004\n\n- **需求ID**: FR-007\n- **需求描述**: 提供模型透明性输出\n- **优先级**: 中\n- **验收标准**:\n  - 输出特征重要度信息\n  - 提供预测区间等可解释信息\n  - 输出格式清晰易读\n- **依赖关系**: FR-004\n\n#### 2.2.3 策略执行与回测模块\n\n- **需求ID**: FR-008\n- **需求描述**: 实现信号转换适配器，将Qlib预测转换为Hikyuu信号格式\n- **优先级**: 高\n- **验收标准**:\n  - 支持Qlib的pred.pkl（MultiIndex DataFrame）转换\n  - 输出Hikyuu内置信号格式（CSV/JSON）\n  - 支持Top-K选股与择时信号映射规则\n- **依赖关系**: FR-004\n\n- **需求ID**: FR-009\n- **需求描述**: 提供回测脚本，调用Hikyuu内置功能完成回测\n- **优先级**: 高\n- **验收标准**:\n  - 调用Hikyuu内置的Portfolio/TradeManager\n  - 输出收益曲线与关键指标\n  - 支持CSV或图形结果输出\n- **依赖关系**: FR-008\n\n- **需求ID**: FR-010\n- **需求描述**: 实现基础调仓建议功能\n- **优先级**: 中\n- **风险预判**:\n  - 调仓建议展示不清晰\n  - 用户理解偏差导致错误决策\n- **验收标准**:\n  - 在GUI/命令行中展示格式化调仓建议\n  - 支持用户查看建议详情\n  - 调仓建议包含明确的买入/卖出信号\n  - 提供简单的风险提示\n- **依赖关系**: FR-009\n\n#### 2.2.4 配置与复盘模块\n\n- **需求ID**: FR-011\n- **需求描述**: 实现配置优先设计，所有参数可配置化\n- **优先级**: 高\n- **验收标准**:\n  - 所有可变参数统一抽离至config.yaml\n  - 用户80%场景仅需修改配置\n  - 配置文件结构清晰，易于理解\n- **依赖关系**: 无\n\n- **需求ID**: FR-012\n- **需求描述**: 提供端到端示例策略\n- **优先级**: 高\n- **验收标准**:\n  - 包含数据准备、Qlib训练/预测完整流程\n  - 包含信号转换、Hikyuu回测与基础报告\n  - 示例策略可正常运行并产生预期结果\n- **依赖关系**: FR-004, FR-008, FR-009\n\n- **需求ID**: FR-013\n- **需求描述**: 实现日志与监控功能\n- **优先级**: 中\n- **风险预判**:\n  - 日志文件过大占用存储空间\n  - 日志信息过于冗余或不足\n  - 敏感信息泄露风险\n- **验收标准**:\n  - 记录数据更新、训练、信号生成、执行结果\n  - 提供简易日志管理界面\n  - 支持日志查询和过滤\n  - 日志文件自动轮转和清理\n  - 日志级别可配置（DEBUG/INFO/WARN/ERROR）\n  - 敏感信息自动脱敏处理\n- **依赖关系**: FR-004, FR-009\n\n- **需求ID**: FR-014\n- **需求描述**: 提供复盘工具\n- **优先级**: 中\n- **风险预判**:\n  - 复盘数据统计错误\n  - 图表展示不准确或误导\n  - 多策略对比基准不一致\n- **验收标准**:\n  - 自动生成策略回测结果CSV\n  - 生成基础收益曲线图表\n  - 支持对比多个实验的回测表现\n  - 复盘数据准确性校验\n  - 支持多种图表类型（线图、柱状图、散点图等）\n  - 策略对比基准可配置（如沪深300、中证500等）\n- **依赖关系**: FR-009, FR-013\n\n## 3. 用户故事\n\n### 3.1 数据准备流程\n\n**作为** 量化爱好者\n**我想要** 一键加载Hikyuu行情数据到Qlib\n**以便于** 快速开始机器学习建模\n\n**验收条件**:\n\n- 能够通过向导配置数据源\n- 数据加载过程有进度提示\n- 加载完成后显示数据概览信息\n\n### 3.2 模型训练流程\n\n**作为** 技术指标型交易者\n**我想要** 使用预设脚本快速训练AI模型\n**以便于** 验证技术指标的预测能力\n\n**验收条件**:\n\n- 提供默认模型配置和训练脚本\n- 训练过程实时显示进度和关键指标\n- 训练完成后自动保存模型和预测结果\n\n### 3.3 策略验证流程\n\n**作为** 兼职自营投资者\n**我想要** 将AI预测信号转换为可执行的交易策略\n**以便于** 在实际交易中参考AI建议\n\n**验收条件**:\n\n- 预测信号能自动转换为交易信号\n- 支持回测验证策略表现\n- 提供清晰的可视化结果展示\n\n### 3.4 风险控制流程\n\n**作为** 兼职自营投资者\n**我想要** 在执行交易前进行人工确认\n**以便于** 控制交易风险并保持决策主导权\n\n**验收条件**:\n\n- 交易建议明确标示为\"建议\"性质\n- 提供多重风控阈值设置\n- 支持人工确认机制\n\n## 4. 数据需求\n\n### 4.1 数据实体\n\n- **行情数据**: 包含开高低收量额、复权因子等核心字段\n- **特征数据**: 技术指标计算结果，如EMA、MACD、RSI等\n- **预测数据**: Qlib模型输出的pred.pkl文件\n- **信号数据**: 转换后的Hikyuu信号格式（CSV/JSON）\n- **配置数据**: YAML格式的参数配置文件\n- **日志数据**: 训练、转换、执行过程的记录信息\n\n### 4.2 数据流\n\n1. **数据准备流**: Hikyuu HDF5数据 → HikyuuDataLoader → Qlib Dataset\n2. **特征计算流**: 原始数据 → 特征模板 → Qlib特征数据\n3. **模型训练流**: 特征数据 → 训练脚本 → 模型文件 + 预测结果\n4. **信号转换流**: Qlib预测结果 → 信号转换器 → Hikyuu信号格式\n5. **策略执行流**: Hikyuu信号 → 回测引擎 → 执行结果 + 回测报告\n6. **配置管理流**: 配置文件 → 各模块参数 → 运行时配置\n\n## 5. 假设和依赖\n\n### 5.1 假设\n\n- **用户技术能力**: 用户具备基本的命令行操作能力\n- **数据完整性**: 用户已获取合法的行情数据源\n- **硬件环境**: 用户拥有满足最低配置要求的硬件设备\n- **网络环境**: 用户在数据更新时能正常访问网络\n- **监管合规**: 用户遵守当地金融监管政策\n\n### 5.2 依赖\n\n- **Hikyuu框架**: 依赖Hikyuu提供的行情数据获取、回测引擎等功能\n- **Qlib框架**: 依赖Qlib提供的机器学习建模、特征工程等功能\n- **Python环境**: 依赖Python 3.8+及相关机器学习库\n- **数据存储**: 依赖HDF5格式存储历史行情数据\n- **配置管理**: 依赖YAML格式进行参数配置\n"},"tasks":{"lastTaskId":"b84c1b33-be81-45e8-98bf-2c845e9cbc2d","lastCheckpointId":"5e0155ed7e3e05c68e1667f9cbd28556cecff57e","content":"# 任务规划文档 - Hikyuu × Qlib 个人量化工作站\n\n## 任务规划\n\n- [ ] 1. 实现【数据流通模块】功能子需求\n  - 实现HikyuuDataLoader类，使用hikyuu.StockManager.instance()加载Hikyuu HDF5数据\n  - 实现HikyuuDataExtractor类，从Hikyuu KData中提取开高低收量额、复权因子等核心字段\n  - 实现QlibDataConverter类，将Hikyuu数据转换为Qlib所需的MultiIndex DataFrame格式（datetime, instrument）\n  - 实现QlibFeatureCalculator类，基于Hikyuu技术指标计算Qlib特征表达式，支持EMA、MACD、RSI等\n  - 实现QlibFeatureExpressionBuilder类，构建Qlib特征表达式，支持$close、$volume等变量\n  - 实现QlibDatasetBuilder类，使用qlib.data.D.save()构建Qlib Dataset并生成.bin格式数据\n  - 实现DataConfiguration类，管理Hikyuu数据目录、市场、标的、时间范围配置\n  - 实现DataIntegrityValidator类，验证数据转换的完整性和准确性\n  - 实现命令行工具hikyuu-qlib-data，支持init、convert、validate等子命令\n  - 确保子需求可独立运行\n  - _需求：[FR-001, FR-002, FR-003]_\n\n- [ ] 2. 实现【机器学习建模模块】功能子需求\n  - 实现QlibWorkflowManager类，使用qrun命令和YAML配置管理模型训练工作流\n  - 实现ModelTrainer类，集成Qlib的LGBModel、MLP、LSTM等模型训练功能\n  - 实现ModelPredictor类，使用训练好的模型进行预测并生成pred.pkl文件\n  - 实现QlibRecorderIntegration类，集成Qlib Recorder进行实验记录和管理\n  - 实现ModelAnalysis类，提供IC分析、风险分析、累积收益分析功能\n  - 实现快速训练脚本，支持一键训练并生成预测结果\n  - 实现命令行工具hikyuu-qlib-train，支持train、predict、list等子命令\n  - 确保子需求可独立运行\n  - _需求：[FR-004, FR-005, FR-006, FR-007]_\n\n- [ ] 3. 实现【策略执行模块】功能子需求\n  - 实现QlibPredictionParser类，解析Qlib pred.pkl文件中的预测结果\n  - 实现PredictionScoreProcessor类，处理预测分数的标准化和阈值过滤\n  - 实现TopKStockSelector类，实现基于预测分数的Top-K选股逻辑\n  - 实现CustomSG_QlibFactor类，继承自hikyuu.SignalBase，将Qlib预测结果转换为Hikyuu信号\n  - 实现HikyuuTradeManager集成，使用hikyuu.TradeManager进行交易账户管理\n  - 实现HikyuuSystemComposer类，构建完整的Hikyuu交易系统（SG、MM、ST、TP、EV、CN、SP）\n  - 实现HikyuuPortfolioManager类，使用hikyuu.trade_sys进行投资组合管理\n  - 实现基础调仓建议功能，基于预测结果和资金管理策略生成调仓建议\n  - 实现命令行工具hikyuu-qlib-backtest，支持run、report、summary等子命令\n  - 确保子需求可独立运行\n  - _需求：[FR-008, FR-009, FR-010]_\n\n- [ ] 4. 实现【配置管理模块】功能子需求\n  - 实现ConfigBridge类，作为Hikyuu INI和Qlib YAML配置的桥接层，统一管理两种格式配置\n  - 实现INIConfigLoader类，负责Hikyuu INI配置文件的加载和解析，支持[hikyuu]、[baseinfo]、[kdata]、[preload]等节\n  - 实现YAMLConfigLoader类，负责Qlib YAML配置文件的加载和解析，支持data、model、strategy、backtest等配置\n  - 实现QlibConfigValidator类，负责Qlib相关配置参数的验证，检查必要的配置键是否存在\n  - 实现HikyuuConfigValidator类，负责Hikyuu相关配置参数的验证，检查必需的配置节是否存在\n  - 实现ConfigManager类，负责配置的版本管理和更新，支持配置文件的版本控制和回滚\n  - 实现EnvironmentSetup类，负责Hikyuu和Qlib环境初始化和配置，使用load_hikyuu()和qlib.init()\n  - 实现配置优先设计，所有参数可配置化，支持通过命令行参数覆盖配置文件中的设置\n  - 实现命令行工具hikyuu-qlib-config，支持generate、validate、update等子命令，使用Click框架实现\n  - 确保子需求可独立运行\n  - _需求：[FR-011]_\n\n- [ ] 5. 实现【复盘分析模块】功能子需求\n  - 实现HikyuuPerformanceAnalyzer类，使用hikyuu.Performance分析回测结果\n  - 实现QlibAnalysisIntegration类，集成Qlib分析功能进行结果评估\n  - 实现HikyuuVisualization类，使用hikyuu.interactive进行结果可视化\n  - 实现StrategyComparator类，负责多策略对比分析\n  - 实现ReportGenerator类，负责回测报告的生成\n  - 实现日志与监控功能，记录数据更新、训练、信号生成、执行结果\n  - 实现命令行工具hikyuu-qlib-analyze，支持report、compare、plot等子命令\n  - 确保子需求可独立运行\n  - _需求：[FR-012, FR-013, FR-014]_\n\n- [ ] 6. 实现【Hikyuu Python API集成】功能子需求\n  - 实现HikyuuInitializer类，使用load_hikyuu()初始化Hikyuu框架，支持config_file、stock_list、ktype_list、preload_num等参数\n  - 实现HikyuuStockManagerWrapper类，封装hikyuu.StockManager的证券管理功能，支持获取证券列表、基本信息\n  - 实现HikyuuKDataWrapper类，封装hikyuu.KData的数据查询功能，支持Query对象和多种K线类型\n  - 实现HikyuuIndicatorWrapper类，封装hikyuu.indicator的技术指标计算功能，支持EMA、MACD、RSI等\n  - 实现HikyuuTradeManagerWrapper类，封装hikyuu.TradeManager的交易管理功能，支持crtTM()创建\n  - 实现HikyuuSystemComposer类，使用SYS_Simple()创建交易系统，正确配置SG、MM、ST、SP组件\n  - 实现HikyuuPortfolioWrapper类，封装hikyuu.trade_sys的投资组合功能，支持PF_Simple()和PF_WithoutAF()\n  - 实现HikyuuPerformanceAnalyzer类，使用hikyuu.Performance进行回测绩效分析\n  - 实现HikyuuInteractiveWrapper类，封装hikyuu.interactive的绘图功能，支持K线图、指标图\n  - 实现HikyuuEventDrivenBacktest类，支持事件驱动回测功能，使用backtest()函数\n  - 确保子需求可独立运行\n  - _需求：[FR-001, FR-008, FR-009]_\n\n- [ ] 7. 实现【Qlib API集成】功能子需求\n  - 实现QlibInitializer类，使用qlib.init()初始化Qlib框架，配置provider_uri、region、redis_host、redis_port、expression_cache、dataset_cache等参数\n  - 实现QlibDataLoaderWrapper类，封装qlib.data.D的数据加载功能，支持$close、$volume、Ref($close, 1)等表达式\n  - 实现QlibDataProcessor类，使用Qlib的DropnaProcessor、ZscoreNorm、CSRankNorm等处理器进行特征工程\n  - 实现QlibDatasetWrapper类，封装qlib.data.Dataset管理功能，支持特征表达式和数据集构建\n  - 实现QlibModelWrapper类，封装qlib.model的模型训练和预测功能，支持LGBModel、MLP、LSTM等\n  - 实现QlibWorkflowWrapper类，封装qlib.workflow的工作流管理功能，支持qrun和YAML配置\n  - 实现QlibRecorderWrapper类，封装qlib.workflow.R的实验记录功能，支持MLflow集成和SignalRecord、PortAnaRecord\n  - 实现QlibAnalysisWrapper类，封装qlib.evaluate的分析和评估功能，支持IC分析、风险分析\n  - 实现QlibExpressionWrapper类，封装Qlib表达式引擎，支持特征表达式和Alpha因子\n  - 实现QlibPortfolioStrategyWrapper类，封装TopkDropoutStrategy等投资组合策略\n  - 确保子需求可独立运行\n  - _需求：[FR-002, FR-004, FR-005]_\n\n- [ ] 8. 实现【信号转换处理】功能子需求\n  - 实现QlibPredictionParser类，解析Qlib pred.pkl文件中的MultiIndex(datetime, instrument)预测结果\n  - 实现PredictionScoreNormalizer类，实现预测分数的标准化（Z-Score、Min-Max等）\n  - 实现DynamicThresholdCalculator类，基于统计方法动态计算信号阈值\n  - 实现TopKStockSelector类，实现基于预测分数的Top-K选股逻辑，支持等权重和市值加权\n  - 实现TimingSignalMapper类，将预测分数映射为Hikyuu的买入/卖出信号（+1/-1/0）\n  - 实现SignalTimeAligner类，处理预测信号与Hikyuu K线的时间对齐问题\n  - 实现CustomSG_QlibFactor类，继承自hikyuu.SignalBase，重写_calculate()方法，集成Qlib预测结果\n  - 实现SignalRecordManager类，使用Qlib的SignalRecord和PortAnaRecord进行信号记录和投资组合分析\n  - 实现SignalValidator类，验证信号格式和有效性，确保符合Hikyuu交易系统要求\n  - 实现CSVJSONSignalFormatter类，支持CSV/JSON多种输出格式，兼容Hikyuu外部信号接口\n  - 实现EventDrivenSignalProcessor类，支持事件驱动的信号处理，与Hikyuu事件驱动回测结合\n  - 确保子需求可独立运行\n  - _需求：[FR-008]_\n\n- [ ] 9. 实现【端到端示例策略】功能子需求\n  - 实现技术指标策略示例，使用SG_Cross(MA(CLOSE(), 5), MA(CLOSE(), 20))构建双均线交叉策略\n  - 实现机器学习择时策略示例，展示Qlib LGBModel训练与CustomSG_QlibFactor信号转换的完整流程\n  - 实现多因子选股策略示例，使用PF_Simple + SE_PerformanceOptimal构建投资组合\n  - 实现组合策略示例，展示MM_FixedPercent资金管理 + ST_FixedPercent止损 + ST_FixedPercent止盈的组合使用\n  - 实现滚动交易系统示例，使用SYS_WalkForward构建滚动训练和回测系统\n  - 实现实时策略示例，展示Hikyuu实时数据获取和交易信号生成\n  - 实现配置文件示例，展示数据源配置、模型配置、策略配置的完整YAML结构\n  - 实现信号转换示例，展示从Qlib pred.pkl到Hikyuu交易信号的完整转换过程\n  - 确保子需求可独立运行\n  - _需求：[FR-012]_\n\n- [ ] 10. 实现【数据流完整性验证】功能子需求\n  - 实现HikyuuDataValidator类，使用Hikyuu API验证输入数据质量\n  - 实现QlibDataValidator类，使用Qlib API验证数据转换正确性\n  - 实现PredictionValidator类，验证模型输出有效性\n  - 实现SignalValidator类，验证信号格式正确性\n  - 实现BacktestValidator类，使用Hikyuu Performance验证执行结果可靠性\n  - 实现EndToEndValidator类，确保整个流程的数据一致性\n  - 确保子需求可独立运行\n  - _需求：[FR-001, FR-002, FR-004, FR-008, FR-009]_\n\n- [ ] 11. 实现【滚动交易系统集成】功能子需求\n  - 实现SYS_WalkForwardIntegration类，集成Hikyuu的SYS_WalkForward滚动寻优系统\n  - 实现CandidateSystemCreator类，基于不同Qlib模型创建候选交易系统列表\n  - 实现CustomSelector类，继承自hikyuu.SelectorBase，支持自定义选择标准\n  - 实现WalkForwardSystemRunner类，执行滚动寻优回测并收集结果\n  - 实现PerformanceBasedSelector类，基于SE_PerformanceOptimal实现绩效选择器\n  - 实现RollingWindowManager类，管理训练期和测试期的滚动窗口\n  - 实现SystemSwitchingLogic类，处理系统切换逻辑和交易连续性\n  - 实现命令行工具hikyuu-qlib-backtest的walkforward子命令，支持滚动寻优回测\n  - 确保子需求可独立运行\n  - _需求：[FR-009, FR-010]_\n\n- [ ] 12. 实现【批量系统分析】功能子需求\n  - 实现BatchSystemAnalyzer类，集成Hikyuu的analysisSystemList批量分析功能\n  - 实现MultiModelSystemGenerator类，生成基于多个Qlib模型的交易系统\n  - 实然ParallelAnalysisExecutor类，利用Hikyuu的parallel_for_index进行并行计算\n  - 实现AnalysisResultProcessor类，处理批量分析结果并生成统计报告\n  - 实现SystemPerformanceComparator类，对比多个系统的绩效指标\n  - 实现BatchAnalysisExporter类，导出批量分析结果到CSV/Excel格式\n  - 实现命令行工具hikyuu-qlib-analyze的batch子命令，支持批量系统分析\n  - 确保子需求可独立运行\n  - _需求：[FR-012, FR-013, FR-014]_\n\n- [ ] 13. 实现【可视化功能集成】功能子需求\n  - 实现SystemVisualizer类，集成Hikyuu的sys_performance系统绩效可视化功能\n  - 实现HeatmapVisualizer类，集成Hikyuu的sys_heatmap收益热力图可视化功能\n  - 实现BatchSystemVisualizer类，实现多系统对比可视化\n  - 实现WalkForwardResultVisualizer类，可视化滚动寻优系统的切换时机和绩效\n  - 实现InteractiveChartGenerator类，生成交互式图表和报告\n  - 实现VisualizationExporter类，导出可视化结果到HTML/PDF格式\n  - 实现命令行工具hikyuu-qlib-analyze的plot子命令，支持多种可视化类型\n  - 确保子需求可独立运行\n  - _需求：[FR-012, FR-014]_\n\n- [ ] 14. 实现【命令行工具打包】功能子需求\n  - 实现setup.py配置，使用entry_points配置五个主要命令行工具\n  - 实现CLI模块结构，将五个命令行工具分别组织到cli子模块中\n  - 实现Click框架集成，为所有命令行工具提供统一的参数验证和帮助文档\n  - 实现命令行工具依赖管理，确保所有必需的Python包正确安装\n  - 实现命令行工具测试，确保所有子命令正常工作\n  - 实现安装脚本，支持一键安装所有命令行工具\n  - 实现命令行工具文档，提供详细的使用说明和示例\n  - 确保子需求可独立运行\n  - _需求：[FR-011]_"},"version":"1.0.0","lastModified":"2025-11-11T01:13:54.700Z"}